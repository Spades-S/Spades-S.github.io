[{"title":"css权威指南-视觉格式化","url":"/2018-03-05-css权威指南-视觉格式化/","content":"\n在《CSS权威指南》前七个章节里，视觉格式化是最有意思的一个章节，也是值得反复阅读的章节。\n\n{% asset_img img-1.png %}\n\n章节大的骨架如上。从格式化的对象上可以分为两个大类，块级元素和行内元素。块级元素有两方面的格式化，一个是水平格式化，另一个，垂直格式化。行内元素需要进行行内格式化，行内格式化同样可以根据格式化对象的不同分为行内替换元素格式化、行内非替换元素格式化。\n\n对于一部分前端从业者，更熟悉的应该是块级元素视觉格式化，相较于行内元素视觉格式化，块级元素视觉格式化更加简单。\n\n## 块级元素\n\n**1. 水平格式化**\n\n在块级元素水平格式化并且**仅在水平格式化**里有一个公式，掌握了这个公式基本可以解决80%的问题：\n\n`margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = width of ParaentElement`\n\n* 使用auto\n\n  在`width`  `padding`  `border`  `margin`  这四个属性里，能够将值设置为auto的只有 `width`  `margin-left`  `margin-right` \n\n  **如果三个值同时指定**， 在  **ltr**  语言中，用户代理会强制将`margin-right`置为auto\n\n  **只有一个值为auto**时，被设置为auto的属性将会自行确定所需的长度 ( 根据公式 ) \n\n  **有两个值为auto**时，如果是`margin-left` 和 `margin-right` 被设置为auto，该元素将会水平居中；如果是两个auto中包含`width`，被设置为auto的margin值将会等于0\n\n  **有三个值为auto**时，此时`margin-left` 、`margin-right` 都会等于0\n\n  总结：`margin-left`  `margin-right`  `width` 三个属性的优先级：`width` > (`margin-left` = `margin-right`)，优先级高的属性将会抢先占据父元素width中尚未被占用的宽度 \n\n* 负边距\n\n  一般的问题可以通过公式来解决\n\n* 百分数\n\n  `width`  `margin`  `padding`  的百分数值均以父元素宽度作为参考\n\n**2. 垂直格式化**\n\n块级元素垂直格式化是**不存在七个属性相加等于父元素宽度的公式的！！**\n\n* 使用auto\n\n  如果块级正常流元素高度设置为auto，并且只有块级子元素，其默认高度是**从最高块级子元素的外边框边界到最低块级子元素的外边框边界**。**当块级元素有内边距或者是边框时，其高度将会从最高子元素上外边距边界到最低子元素下外边距边界**。\n\n* 外边距合并\n\n  在外边距合并上，最合理的解释应该是：**同一个BFC中的相邻外边距会发生合并**\n\n## 行内元素\n\n{  `行框`  {  `行内框`   {  `内容区`  }  } }\n\n**行框**： 包含该行中出现的行内框的最高点和最低点的最小框。 \n\n**行内框**：对于非替换元素，元素行内框高度等于line-height；对于替换元素，元素框高度等于内容区高度。非替换元素的外边距不会对行内框的高度产社任何影响，会影响到行内框的宽度。\n\n**内容区**：对于非替换元素，内容区是各个字符的em框串在一起的框；对于替换元素，内容区是元素固有高度+可能有的内外边距和边框。\n\n总结：每一个行框内会包含若干行内框\n\n**1. 行内非替换元素**\n\n非替换元素的内容区高度由font-size值确定，行内框高度由line-height值确定。当line-height值小于font-size时，行间距会取得负值。行间距 = line-height - font-size。当行间距为负值时，元素行内框的顶端在内容区内部。\n\n**2. 行内替换元素**\n对于行内替换元素，内边距会在**具体内容外插入空间**。给替换元素设置负外边距会减少替换元素行内框的大小。\n\n默认情况下，行内替换元素位于基线上。\n\n**3. line-height**\n\n这里单独把line-height拿出来作为一个点。\n\n* 由于line-height会被子元素继承，在给line-height赋值时最好将其设置为原始数字值，将其设为缩放因子。其具体的line-height计算值 = 元素font-size * line-height缩放因子 \n* 另一个需要关注的点：如果给vertical-align设置百分数值，其计算值 = line-height计算值 * 百分数值\n\n","tags":["阅读整理"],"categories":["CSS"]},{"title":"The-Stacking-Context","url":"/2018-01-08-The-Stacking-Context/","content":"\nCSS，Cascading Style Sheet，层叠样式表，从字面上来看CSS最关键的三点，层叠、样式、表，这三个关键点里，`样式`说明了CSS的作用目标、功用，`表`说明了CSS的长相，而`层叠`表述的是CSS自身有何特点。CSS这东西不比人，并不能因为姓名和长相而让使用者记住它，只有`层叠`这个特质，能够让人从万千事物中分辨出它。\n\n层叠，意味着`可覆盖`，用户只能够看到最上层的东西，开发者必须将最终要的东西放在最上面，让用户能够一眼就看到。为了实现这个目标，开发者必须弄懂页面是按照何种方式、何种顺序绘制层叠上下文的。\n\n在学习层叠上下文绘制顺序之前，我们需要了解什么情况下会生成层叠上下文。能够产生层叠上下文的常见情况：\n\n```\nHTML文档的根元素；\nposition属性值为absolute或者relative并且z-index值不为auto的元素；\nposition属性值为fixed或者是sticky的元素(position:sticky在所有移动端浏览器上均生成层叠上下文，在老的pc浏览器上不会)；\nflex 容器里的元素，并且其z-index不为auto；\nopacity值小于1的元素；\ntransform、filter属性值不为none的元素；\n```\n\n>  以上是我觉得比较常见的几种情况，当然这也只是一部分，全部情况可以参看[The stacking context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)。\n\n现在我们可以去学习层叠上下文在页面绘制时是按照何种顺序进行绘制的了。**需要强调的是下面说的顺序只在一个层叠上下文中适用**\n\n**from BACK  to FRONT**\n\n```\n层叠上下文的根元素；\nz-index值为负数的定位元素(positioned elements)及其子元素；\n非定位元素(同为该种元素时按照HTML文档中的先后顺序)；\nz-index值为auto的定位元素及其子元素（同为该种元素时按照HTML文档中的先后顺序）；\nz-index值为正数的定位元素及其子元素；\n```\n\n\n\n> 又要当一次小偷了，[What No One Told You About Z-Index](https://philipwalton.com/articles/what-no-one-told-you-about-z-index/)这篇文章写的太好了，我不忍心去翻译，翻译出来的像狗啃过的（我还特地看了下左上角的intro，Philip Walton engineer @ Google，由衷感叹谷歌的工程师真牛逼）\n\n文章部分内容摘录如下：\n\n### Global Stacking Order\n\nWith a firm understanding of how/when new stacking contexts are formed as well as a grasp of the stacking order within a stacking context, figuring out where a particular element will appear in the global stacking order isn’t so bad.\n\nThe key to avoid getting tripped up is being able to spot when new stacking contexts are formed. If you’re setting a z-index of a billion on an element and it’s not moving forward in the stacking order, **take a look up its ancestor tree and see if any of its parents form stacking contexts. If they do, your z-index of a billion isn’t going to do you any good**.\n\n### Wrapping Up\n\nGetting back to the original problem, I’ve recreated the HTML structure adding comments within each tag indicating its place in the stacking order. This order is assuming the original CSS.\n\n> 这块如果没有前文的CSS代码，是很难读懂的，CSS代码如下\n>\n> .red, .green, .blue {\n>   position: absolute;\n> }\n> .red {\n>   background: red;\n>   z-index: 1;\n> }\n> .green {\n>   background: green;\n> }\n> .blue {\n>   background: blue;\n> }\n\n```html\n<div><!-- 1 -->\n  <span class=\"red\"><!-- 6 --></span>\n</div>\n<div><!-- 2 -->\n  <span class=\"green\"><!-- 4 --><span>\n</div>\n<div><!-- 3 -->\n  <span class=\"blue\"><!-- 5 --></span>\n</div>\n\n```\n\n> 这个地方为什么是先渲染了div ，然后才渲染其中的span呢？\n>\n> [spec](https://www.w3.org/TR/CSS2/zindex.html)中的两条规则应该就是最合理的解释（标号沿用了文档中的标号）：\n>\n> 4    *  For all its in-flow, non-positioned, block-level descendants in tree order: If the element is a block, list-item, or other block equivalent:\n> 1. background color of element.\n> 2. background image of element.\n> 3. border of element.\n>\n>  \n>\n> 7    * Otherwise: first for the element, then for all its in-flow, non-positioned, block-level descendants in tree order:\n> 1. If the element is a block-level replaced element, then: the replaced content, atomically.\n> 2. Otherwise, for each line box of that element:\n>\n> 我的理解：在一个层叠上下文中，首先绘制的是在文档流中的非定位块级后代元素，然后是line-box（这里还是有待进一步考证）\n\nWhen we add the opacity rule to the first `<div>`, the stacking order changes like so:\n\n> add opacity rule to the first div:\n>\n> div:first-child {\n>   opacity: .99;\n> }\n\n```html\n<div><!-- 1 -->\n  <span class=\"red\"><!-- 1.1 --></span>\n</div>\n<div><!-- 2 -->\n  <span class=\"green\"><!-- 4 --><span>\n</div>\n<div><!-- 3 -->\n  <span class=\"blue\"><!-- 5 --></span>\n</div>\n\n```\n\n`span.red` used to be `6` but it’s changed to `1.1`. I’ve used dot notation to show that a new stacking context was formed and `span.red` is now the first element within that new context.\n\nHopefully it’s now a little more clear why the red box moved behind the other boxes. The original example contained only two stacking contexts, the root one and the one formed on `span.red`. When we added opacity to the parent element of `span.red` we formed a third stacking context and, as a result, the z-index value on `span.red` only applied within that new context. Because the first `<div>` (the one we applied opacity to) and its sibling elements do not have position or z-index values set, their stacking order is determined by their source order in the HTML, which means the first `<div>`, and all the elements contained within its stacking context, are rendered behind the second and third `<div>` elements.\n\n> 上面摘录的片段，最主要是用以说明**z-index 是在positioned元素上起作用，z-index只影响该元素在父层叠上下文层级间的前后顺序**\n>\n>  **Importantly, the z-index values of its child stacking contexts only have meaning in this parent. From MDN**\n\n\n\n### conclusion\n\n1. opacity 小于0 形成的层叠上下文，最大的功用就是形成了层叠上下文，对层叠上下文中的层级并没有半点影响（个人感觉）\n2. 如果真的想对层叠上下文有个更加深入的了解，还是看[spec](https://www.w3.org/TR/CSS2/zindex.html)比较好，层叠上下文中各个元素、子层叠上下文的渲染顺序是什么样的，[spec](https://www.w3.org/TR/CSS2/zindex.html)解释的应该是最全的了。","tags":["个人总结"],"categories":["CSS"]},{"title":"bye，我的2017","url":"/2018-01-01-bye，我的2017/","content":"\n> 這篇文章起源於給一個朋友的信，信中內容盡是自己一年來的回憶，寫完整理了下，當做自己17年的文字記錄，我很少留存圖片記錄，能留下一些文字記錄也彌足珍貴了\n\n寫下這些文字的時候已經是2018年了，從一個新的節點往回看，總會覺得時間過得很快，確實啊，2017年過得有些匆忙，上半年忙著離開民族大學，下半年忙著些什麼也說不太清楚，總歸，瞎忙吧。\n\n17年，我的本科生活結束了，班裡的散伙飯吃的挺匆忙的，我的感覺是這樣的，那個時候大家都各自有很多事情，很難找到一個時間一塊吃頓飯。匆忙定了個時間，班裡租了個地方，飯是自己做的，種類挺豐富的，現在我能記住的只有那麼幾件事：胖子（ZSX）是大廚，做了好些吃的，印象中是受到了一致好評，但是具體我吃沒吃到胖子做的菜我記不清楚了，我只記得當時我只盯著我面前的那盤菜吃，其他的菜好像是沒下過筷子；米飯不好吃，放的水有點多了，煮的比較爛，我不太喜歡吃這種米飯；我竟然有燒烤天賦，我烤的串比朱老師烤的好吃很多，當然是吃過我烤的串兒的朋友告訴我的，我自己是不吃我烤的串兒的，我分辨不出熟沒熟（如果以後我真的開了串兒吧，來吃的朋友一定要當心），這也是我一直不會做菜的原因之一。那頓飯我吃的是沒什麼感覺的，不是我想象中的把酒惜別又或是一曲高歌頌別離，大家都還是以一個小圈子在玩，以宿舍為單位的那種，也可能是我沒放開，沒能融入進去。\n\n賢哥（MJX）是最早離校的，我記憶中是送他出了六號樓的大門，沒有擁抱一下也沒有說太多話，好像只有一句一路順風吧。賢哥給我留下的最大一筆財富就是他的飯卡了。我記得是兩位數以上的餘額。拿著賢哥的卡，呼朋引伴，真的是呼朋引伴，324和317都有，一塊在風味食堂吃了一頓，好像是香鍋，由於刷別人的卡的感覺實在太爽，刷卡的的時候情不自禁說了一句“刷別人卡的感覺真爽”，窗口大姐盯著我看了很久，用一種極其古怪的眼神，最後老夫（TH）受不了這種眼神（刷卡的時候老夫是站在我邊上的），解釋了下“用的室友的卡”，大姐才收回那古怪的眼神。\n\n自此，每有一個離校，我就會多收到一張飯卡，到我自己離校的時候，手裡已經有四五張卡了。\n\n{% asset_img bye-1.jpeg %}\n\n到了2017年下半年，總有一些奇怪的事情：體檢有一項指標不合格，校醫院給通知的時候，我總擔心自己是不是得了什麼絕症，複查結果出來前的那十來天時間里我特別忐忑，好在最終是一場虛驚。後面，好像是10月份這樣，手腕又出現了一個囊腫，不過沒什麼大影響。經歷了這幾個事，尤其是第一件，我發現我自己真的挺怕死的，生命也著實很寶貴。\n\n17年基本就是這樣了。\n\n18年了，新年快樂  ^_^\n\n","tags":["杂感"],"categories":["随笔"]},{"title":"清除浮动","url":"/2017-12-31-清除浮动/","content":"\n> 很久没有更新过博客了，看了下归档，最新的一篇是11月份写的，再往前就是只能追溯到8月份了，但是今天已经是17年的最后一天了，间隔太久了。除了更新间隔太久之外，博文的质量总体不高，大多只能算是“摘录”，内化的东西比较少。趁着这个机会整理了一下博客，把一些没有必要的都删掉了。往后博客还是得有个固定的更新时间，毕竟`output is input` ，写博文也是重要的一环。\n>\n> 也顺势对分类和标签做个规定吧，分类按照其本义，对博文进行分类，标签呢，就放两个吧，{个人总结+阅读摘录}，具体表述可能会变化，但是总体上是这两个意思。\n\n2017年里，写了两篇关于清除浮动的博文，一篇是经典文章[A new micro clearfix hack](http://nicolasgallagher.com/micro-clearfix-hack/)的翻译，另一篇写的非常水，我自己都看不明白写的是个啥（这两篇博文现在已经删了）。正好前段时间看了些关于清除浮动的资料，有了一点自己的看法，做一个总结。\n\n——————————————————————————————————————————————————\n\n首先我们需要明确的一点是，清除浮动到底清除的是什么？浮动效果由float属性产生，可以使元素脱离常规文档流，有可能会导致浮动元素父级元素对象盒子不能被撑开，形成高度塌陷。到这儿，我们应该清楚，所谓的清除浮动，就是消除由浮动造成的高度塌陷问题。\n\n{% asset_img clearfix-1.png %}\n\n上图所展示的就是一个典型的浮动塌陷，左半部分是显示效果，右半部分是代码。图中代码想实现的效果如下：\n\n{% asset_img clearfix-2.png %}\n\n设置了背景的outer容器应该包含inner容器。\n\n在出现浮动塌陷的时候，就需要我们去做一些hack，让想要的效果显示出来。怎么去做hack呢？按照原理来分，可以分为两类，clear:both 和 生成BFC。 \n\n* clear:both\n\n首先来看一下clear:both，这可能是最古老的清除浮动的方式了（具体是不是最古老还有待考证）。使用clear:both 的常规操作：\n在浮动元素下，加一个div，将其CSS属性设置为：`clear:both`\n\n```html\n<head>\n    <style>\n        .outer {\n            padding: 20px;\n            width: 100%;\n            background: url(./b.jpg)\n        }\n        .inner {\n            float: left;\n            width: 50%;\n            height: 200px;\n            border: 1px solid red;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"outer\">\n        <div class=\"inner\"> inner</div>\n        <div style=\"clear:both\"></div>\n    </div>\n</body>\n```\n\n在添加完`clear:both`这个div之后，刷新一下，发现塌陷问题真的不见了。\n\n但是这是什么原理呢？为了更容易观察，将`clear:both`这个div背景设为紫色，设置其高度为20px，效果如下：\n\n{% asset_img clearfix-3.png %}\n\n**如果将`clear:both`这个属性去掉，会出现什么样的效果呢?**\n\n利用devtools取消clear属性，发现`clear:both`div 最上面的边界是和`float`div最上面的边界等高的。因为float-div脱离了常规文档流，但并不会影响常规文档流的布局。\n\n{% asset_img clearfix-5.png %}\n\n而`clear:both`起到的作用就是，将`clear:both`div强行放到`float`div之后。我的理解，在float元素所在区域其实是不能存在常规文档流布局，那个区域是个真空区域。\n\n> The clear CSS property specifies whether an element can be next to floating elements that precede it or must be moved down below them.  **From MDN**\n\n\n\n* BFC\n\n走过了远古时期，人类文明终于得到了进一步的发展。\n\n使用BFC的方式消除浮动塌陷，于我而言是一个比`clear:both`更加高级的方式，它不会影响HTML布局，不需要空标签。\n\n能够使用BFC的方式来清除浮动塌陷，原因在于：BFC是一个相对独立的区域，一个BFC会包含其中的所有子元素，无论浮动与否。\n\n>  in a [block formatting context](https://www.w3.org/TR/css-display-3/#block-formatting-context), floated boxes affect the layout of surrounding boxes. But their effects do not escape their [formatting context](https://www.w3.org/TR/css-display-3/#formatting-context): the box establishing their [formatting context](https://www.w3.org/TR/css-display-3/#formatting-context) grows to fully contain them, and floats from outside that box are not allowed to protrude into and affect the contents inside the box.                **From W3C-Spec**\n\n可以通过设置一些特殊的属性生成BFC：\n\n1. the root element \n2. float the element\n3. ensure the computed value of `overflow` is not `visible`\n4. set `display` to `inline-block, inline-table, table-cell or table-caption`\n5. set `position` to something other than `static or relative`\n\n\n\n* modern solution\n\n社会在发展，人类在进步，解决浮动塌陷也有了现代化的方法，这个方法即[A new micro clearfix hack](http://nicolasgallagher.com/micro-clearfix-hack/)提及的方法：\n\n```css\n.clearfix:afer{\n  content:'';\n  display: block;\n  clear: both;\n}\n```\n\n之所以会出现这个方法，是由于上述两种方法均存在缺陷，`clear`方法需要额外的标签，`BFC`方法由于需要设置`overflow`之类的属性，会对显示效果产生一定影响。\n\n但是这样还有可能会出现问题，`margin塌陷`，为了防止margin塌陷，可以将其改进为：\n\n```css\n.clearfix:before,\n.clearfix:after {\n  content: ' ';\n  display: table;\n}\n.clearfix:after {\n  clear: both;\n}\n```\n\n这个改进核心在于将`display`属性改为`table`，生成新的BFC，至于before伪元素，我觉得是可有可无的。\n\n\n\n> 在总结过程中，发现了一篇博文，[Understanding the Humble Clearfix](https://www.fuseinteractive.ca/blog/understanding-humble-clearfix)，我觉得是我看过的最好的讲清楚浮动的博文了，这篇博文也参考了[Understanding the Humble Clearfix](https://www.fuseinteractive.ca/blog/understanding-humble-clearfix)\n\n\n\n","tags":["个人总结"],"categories":["CSS"]},{"title":"ghost in vertical-align","url":"/2017-11-24-ghost-in-vertical-align/","content":"Thanks to [CSS深入理解vertical-align和line-height的基友关系](http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/)、 [Deep dive CSS: font metrics, line-height and vertical-align](https://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align)\n\n在布局的时候常常会发现，这个地方怎么多出来一块，理论上应该没有啊，这个“灵异事件”是怎么产生的？\b有一种“ghost”是隐藏在vertical-align下的，\b\b\b我们来一步一步抓住它。\b\n\n首先看下\b存在“ghost”是啥样子  \n{% asset_img ghost1.png [title] %}  \n\b\n实现\b的代码上面布局的代码:\n```html\n<head>\n    <meta charset=\"utf-8\">\n    <title>test</title>\n    <style>\n        * {\n            margin-top: 0;\n            box-sizing: border-box;\n        }\n        \n        div {\n            margin-top: 50px;\n            background: #bebece;\n        }\n        \n        img {\n            height: 200px;\n        }\n    </style>\n</head>\n<body>\n    <div>\n        <img src=\"./anywhere.jpg\" alt=\"\">\n    </div>\n</body>\n```\n代码结构非常近\b简单，\b一个有背景色的div和一张图片，按照常规的逻辑div的高度应该和img的高度一致，div里面只有img，计算高度时只有img的高度，但是奇怪的是，div的高度却要比img高出一些(\b见上图红框)\n\n为什么会出现这种\b\b奇怪的东西呢？张鑫旭\b\b用了一个\b自定义的概念解释了这个现象，“幽灵空白”节点，一个块容器中藏着一个幽灵空白节点，看不见摸不着，但的确存在！\n\n确实像张鑫旭说的那样，在一个块级容器中存在一个“无色无味不可触摸”的幽灵空白节点：\n{% asset_img ghost2.png %}\n上面的截图中，img下面都具有相同的空隙，但是不同的是`在img边上是否存在文字`。\n上面那个图是由如下的代码实现的：\n```html\n<head >\n    <meta charset=\"utf-8\">\n    <title>test</title>\n    <style>\n        * {\n            margin-top: 0;\n            box-sizing: border-box;\n        }\n        \n        div {\n            margin-top: 50px;\n            background: #bebece;\n        }\n        \n        img {\n            height: 200px;\n        }\n    </style>\n</head>\n<body>\n<div>\n    <img src=\"./anywhere.jpg\" alt=\"\">\n</div>\n<div>\n    <img src=\"./anywhere.jpg\" alt=\"\">\n    <span>spades</span>\n</div>\n</body>\n```\n从代码上加以分析，两个div唯一的不同点：是否具有span。div内部加上span之后img表现出的效果竟然和没有span时一致，那么对于第二个div来说，img下面的那个空隙是由span撑开的吗？给span加个背景看看吧\n{% asset_img ghost3.png %}\n从截图上直观地说，span确实是造成img下面有空隙的元凶。既然span是元凶，如果它的高度为0，从逻辑上来讲img下面的空隙就会消失。\n将span的font-size设为0：\n{% asset_img ghost4.png %}\n将span的font-size设置为0之后，span的确是消失了，但是img下面还是存在空隙。如果div里面真的有一个幽灵元素，并且img下的空隙的确是由那个幽灵空白元素造成的，那只给span设置font-size是不是不太够，也需要给那个幽灵元素设置下font-size\n在div上设置font-size：\n{% asset_img ghost5.png %}\n将divfont-size设置为0之后，img下的空隙消失了，在第一个div上设置font-size，img下的空隙同样消失。\n到此我们可以知道，一个块级元素里的确存在一个幽灵空白节点。w3c spec上是这么说的：\n``` text\nOn a block container element whose content is composed of inline-level elements, 'line-height' specifies the minimal height of line  \nboxes within the element. The minimum height consists of a minimum height above the baseline and a minimum depth below it, exactly as \nif each line box starts with a zero-width inline box with the element's font and line height properties. We call that imaginary box a\n\"strut.\"\n```\nw3c spec这段话的意思是说，对于一个内部只有内联元素的块级元素，它的最小高度里包含了minimum height，这个minimum height在baseline上下各有一个，就像是在这个块级容器中有一个宽度为0的元素一样。\n\n对于vartical-align，默认的值是baseline：align the baseline of the box with the baseline of parent box. If the box does not have a baseline, align the bottom with the parent's baseline.\nvertical-align 还有其他几个值：\n—— middle: align the vertical midpoint of the box with the baseline of the parent box plus half the x-height of the parent.\n—— sub: lower the baseline of the box to the proper position for subscripts of the parent's box.(This value has no effect on the font size of the element's text)\n—— super: raise the baseline of the box to the proper position for superscripts of the parent's box.(This value has no effect on the font size of the element's text)\n—— text-top: align the top of the box with the top of the parent's content area.\n—— text-bottom: align the bottom of the box with the bottom of the parent's content area.\n—— percentage\n—— length\n**The vertical-align property affects the vertical positioning inside a line box of the boxes generated by an inline-level element. The values only have meaning with respect to a parent inline element, or to the strut of a parent block container element**\n\n**for inline non-replaced elements, the box used for alignment is the box whose height is the \"line-height\". For other elements, the box used for alignment is the margin box**\n张鑫旭在他的文章里也提到了类似的表述，“css2 可视化格式文档模型中的一段话：The baseline of an 'inline-block' is the baseline of its last line box , unless it has either no in-flow line boxes or if its overflow property has a computed value other than visible, in which case the baseline is the bottom margin edge.” 在这里顺便借用下张鑫旭对这段话的翻译：“一个inline-block元素，如果里面没有inline内联元素，或者overflow不是visible，那么该元素的基线就是其margin底边边缘；否则，基线就是元素里面最后一行内联元素的基线”\n\n除了上面的值之外，vertical-align还可以去top和bottom：\n—— top: align the top of the aligned subtree with the top of the line box.\n—— bottom: align the bottom of the aligned subtree with the bottom of the line box.\n\n回到最初的话题，为什么img下会有空隙呢？原因在于，img 和 幽灵空白节点 的 vertical-align默认值均为baseline，对于img其baseline是margin底边缘，幽灵空白节点的baseline并不是margin底边缘（如下图中的span中文字节点的baseline，span的baseline并不是margin底边缘），所以会出现空隙\n{% asset_img ghost6.png %}\n\n\n\n\n\n\n\n\n\n","tags":["个人总结"],"categories":["CSS"]},{"title":"readlist","url":"/2017-08-29-readlist/","content":"\n[浅阅读]\n\n* [前端性能优化 - 资源预加载](http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/)\n\n* [Node.js 垃圾回收](https://eggggger.xyz/2016/10/22/node-gc/)\n\n* [JavaScript核心概念归纳整理](https://mp.weixin.qq.com/s?__biz=MzI2MTY0NTEyMA==&mid=2247483948&idx=1&sn=0e93dbb8dc3d9c9a439461bbdbc92b37&chksm=ea567403dd21fd156325f9845b0292b812394654bed9ac41dd05a266710504df3445eb8a21b3&mpshare=1&scene=1&srcid=0710k6oGplOMxqvgJRR0L0UG&key=3d8efa8bcd6863c30214801bcb5e016ca5b432ff2a34b0d1cb024ac870b8a7b84c113ca5f2bd479a6d2726075b227e6c57c28e0cb9680fdcdde32bf28e987823df919d0620532c81f46181a93ad9444e&ascene=0&uin=MjA1ODA2MzcxNw%3D%3D&devicetype=iMac+MacBookPro13%2C2+OSX+OSX+10.12.4+build(16E195)&version=12020810&nettype=WIFI&fontScale=100&pass_ticket=40njmq%2B8OTppLcW26M%2Fu06WOkrNbXzpUrJ8lksyxz6B%2BR6E6pvg1GXTdYNbYfEFR)\n\n* [简单明了区分escape、encodeURI和encodeURIComponent](http://www.cnblogs.com/season-huang/p/3439277.html)\n\n* [详解JavaScript模块化开发](https://segmentfault.com/a/1190000000733959)\n\n  [写了十年JS却不知道模块化为何物？](https://blog.wilddog.com/?p=587)\n\n  [深入浅出ES6（十六）：模块 Modules](http://www.infoq.com/cn/articles/es6-in-depth-modules)\n\n* [ES6的工厂函数](https://zhuanlan.zhihu.com/p/28496170?group_id=881572384912609281)\n\n* [理解Service Worker](https://zhuanlan.zhihu.com/p/28461857)\n\n* [什么是访问器属性](https://www.zhihu.com/question/40648241)\n\n* [深入理解JavaScript中的属性和特性](http://www.58maisui.com/2016/11/03/842/)\n\n* [使用Flexible实现手淘H5页面的终端适配](https://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html)\n\n* [再聊移动端页面的适配](https://www.w3cplus.com/css/vw-for-layout.html)\n\n*  [HTML meta标签总结与属性使用介绍](https://segmentfault.com/a/1190000004279791)\n\n*   [AMD, CMD, CommonJS和UMD](https://segmentfault.com/a/1190000004873947)\n\n    ​\n\n\n[深阅读]\n\n* [css模块化及CSS Modules使用详解](http://blog.csdn.net/xiangzhihong8/article/details/53195926)\n\n*  [SCSS 一站式入门](https://github.com/FrankFang/githublog/blob/master/%E6%8A%80%E6%9C%AF/SCSS%20%E4%B8%80%E7%AB%99%E5%BC%8F%E5%85%A5%E9%97%A8.md)\n\n*  [浏览器~加载，解析，渲染](http://www.jianshu.com/p/e141d1543143)\n\n*  [What exactly is Hot Module Replacement in Webpack?)](https://stackoverflow.com/questions/24581873/what-exactly-is-hot-module-replacement-in-webpack)\n\n*  [ HTTP 缓存机制详解](https://mp.weixin.qq.com/s/8UXEMQBkV9hHwtu9R7mV5w)\n\n*  [module.exports vs. export default in Node.js and ES6](https://stackoverflow.com/questions/40294870/module-exports-vs-export-default-in-node-js-and-es6)\n\n*  [详解setTimeout与setInterval](http://danielwan.me/2017/04/detailed-in-settimeout-and-setinterval.html)\n\n*  [Rem布局的原理解析](https://zhuanlan.zhihu.com/p/30413803?hmsr=funteas.com&utm_medium=funteas.com&utm_source=funteas.com)\n\n*  [How JavaScript works: Event loop and the rise of Async programming + 5 ways to better coding with async/await](https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5)\n\n*  [前端精选文摘：BFC 神奇背后的原理](http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html)\n\n*  ​\n\n   ​\n\n\n","tags":["个人总结"],"categories":["readlist"]},{"title":"inline-block元素之间存在间隙、上下不对齐","url":"/2017-08-13-inline-block元素之间存在间隙、上下不对齐/","content":"\n- inline-block元素之间存在间隙\n\n  ```html\n  code-1\n  <div>\n    <span>First element</span>\n    <span>Second element</span>\n  </div>\n  ```\n\n  一般会如code-1编写内联元素，可是在浏览器中观测会发现这两个内联元素之间有几个像素的间隔，这为啥(一脸懵逼状)，这写得也没毛病啊(是吧，老铁？)\n\n  毛病还是有的。**换行符**。这也是这几个像素出现的祸因。\n\n  ```html\n  code-2\n  <div>\n    <span>First element</span><span>Second element</span>\n  </div>\n  ```\n\n  像code-2样编写内联元素，间隙就会消失。但是这也太丑了啊，如果不小心做个对齐，那不就没效果了。\n\n  换行符始终也是字符，也会受到font-size的影响，可以采用如下方法：overwrite  *font-size属性*  解决：\n\n  ```html\n  code-3\n  <style>\n    div{\n      font-size: 0px;\n    }\n    span{\n      font-size: 14px;\n    }\n  </style>\n  <div>\n    <span>First element</span>\n    <span>Second element</span>\n  </div>\n  ```\n\n- Inline-block 元素上下不能对齐\n\n  ```Html\n  code-4\n  <style>\n    \tdiv{\n    \t  font-size: 0px;\n    \t}\n  \tspan{\n        display: inline-block;\n        height: 1.5rem;\n        width: 50%;\n        font-size: 14px;\n  \t}\n    \t.second-element{\n        overflow:auto;\n    \t}\n  </style>\n  <div>\n    <span class=\"first-element\">First element</span>\n    <span class=\"second-element\">Second element</span>\n  </div>\n  ```\n\n  将code-4代码放入浏览器中观察，会发现first-element 和second-element上下不对齐，原因在于**基线不对齐**：``overflow:hidden`` ，这个属性会改变inline-block元素基线位置，导致上下不对齐\n\n  **解决方法**：同时设置两个元素垂直对齐方式``vertical-align:top`` 或者给两个元素同时添加``overflow``属性","tags":["个人总结"],"categories":["CSS"]},{"title":"rollerCoaster遇到的问题整理","url":"/2017-08-13-rollerCoaster遇到的问题整理/","content":"\n“好久没写过博客了，之前的博客也很随意，很多都是一些摘录，总体来说价值量不大。还是得像六哥学习，每周写一两个有价值的。”\n\n这段时间都在做`rollerCoaster`，现在基本上的功能都实现了，做这个项目最初的目的是长长工程经验，从16年下半年开始学习前端，就没有从头到尾地完成一个项目，rollerCoaster刚好给了我这个机会。这个项目的技术架构是我搭的，thinkjs+light7+vue，当时觉得这个架构挺不错的(现在看看，一个词，shit)，虽然这个架构有点屎，但是还是得分析一下：项目要求是webapp，为了便于前端布局，引入了light7，一个ui框架；vue做数据的动态绑定，vue用的非常浅，只是用来进行数据的动态绑定，整个项目都没有写组件，这应该是工程里的非常大的缺陷；thinkjs：基于nodejs的MVC框架，用thinkjs开发起来相当方便，对M和C的封装非常好。\n\n开发完，整体上看，项目的体验比较差，引入的资源太多，加载起来很慢，合理的方式应该是写组件，webpack打包，按需加载，提高用户体验。vue组件开发和webpack也是未来一个月，我学习方向。\n\n开发过程中遇到了不少的问题，对开发过程中的问题做一个整理：\n\n1. 如何更加优雅的处理文本溢出\n\n   ```css\n   //单行文本\n   {\n     overflow: hidden;\n     text-verflow: ellipsis;\n     white-space: nowrap;\n   }\n\n   //多行文本\n   {\n     display: -webkit-box;\n     overflow: hidden;\n     -webkit-line-clamp: 2;  //显示的行数\n     -webkit-box-orient: vertical;\n     text-overflow: ellipisis;\n   }\n   ```\n\n2. overflow : auto在ios上很卡顿\n\n   解决方法：`-webkit-overflow-scrolling: touch` ，这句会启动硬件加速，以达到流畅效果。\n\n   在WebKit 108400版本左右才支持，所以iOS Safari应该是需要5.0。Android则是在4.0以上支持。\n\n3. 在软键盘上显示`搜索`按钮\n\n   一般来说，在input标签上指定`type=\"search\"`即可在软键盘上显示搜索按钮，但是ios是个大BUG，在ios8及其以上版本中，需要在input外层包裹一个`含有action属性的formbba标签`\n\n4. 关于z-index\n\n   z-index只会在仅能在定位元素上生效\n\n5. <input type=\"file\" id=\"input\">多次上传的问题\n\n   对input做change监听可以判断是否上传了文件，但是在不刷新的情况下，再次上传是不会触发`change`的，为了实现reloa这个特性，需要在onchange这个监听函数中，将inpu 的value设置为空，document.getElementById(id).value = null\n\n6. 如何处理：Safari: [“cand 't create duplicate variable that shadows a global property”]\n\n   问题出现场景：\n\n   ```javascript\n   <div class=\"test\"></div>\n   let class = 'test'\n   ```\n\n   问题出现原因：变量名和id值或者class值相同，处理方法：将let换为var即可\n\n   “This is apparently a problem Safari has with declaring a let/const variable that shares the same name as a selected id attribute. I had some variables declared with const as you did and got the same error. Changed to let and still got it. Changed to var and it worked.\n\n\n\n   ​","tags":["个人总结"],"categories":["工程"]},{"title":"mysql修改root密码","url":"/2017-06-06-mysql修改root密码/","content":"\n一直没有从零开始倒腾过mysql，用的都是别人配置好的东西，安装、配置、修改root密码这些都没做过，就试了一下，坑比较多，需要填\n\n操作系统：macOS 10.12.4\n\nMysql：MySQL Community Server 5.7.18\n\nfirst：下载安装包，[mysql官网](https://dev.mysql.com/downloads/mysql/)下载\n\nsecond：安装，首次安装到最后会提示root的初始密码，这个密码记不记不太重要\n\nthird：修改root密码\n\n\t    1. sudo mysqld_safe --skip-grant-tables，进入安全模式\n\t    2. mysql -u root -p ，输入任意密码登录root\n\t    3. UPDATE mysql.user SET authentication_string=PASSWORD(‘123456’) where User=’root’; //将root用户密码改成 123456\n\t    4. flush privileges;  刷新权限，使配置生效\n\t    5. 输入mysql -u root -p命令，接着输入刚刚设置的密码，如果可以登录说明修改成功，则不需要进行下一步\n\t    6. 如果在第5步中出现your password has expired. to log in you must change it using a client that supports expired passwords错误，说明密码过期需要将密码过期字段设置为‘N’\n\t    7. use mysql \n\t    8. select * from mysql.user where user='root' \\G\n\t    9. update user set password_expired='N' where user='root';\n\t    10. flush privileges;  刷新权限，使配置生效\n\t    最后退出mysql，重新mysql\n\n\n\n\n\n折腾完mac上的mysql之后，又倒腾了一下centos server上的mysql\n\n操作系统：CentOs 7.3\n\n[Mysql: 7.5.6](https://dev.mysql.com/downloads/file/?id=469881)\n\n下载的是二进制包，直接解压缩即可\n\nfirst：创建mysql用户账号，`useradd -s /sbin/nologin -M mysql`\n\nsecond：修改配置文件，配置文件一般放在`/etc下，/etc/my.cnf`\n\n```shell\n[client]\nport = 3306\nsocket = /path-to-mysql/mysql.sock\ndefault-character-set = utf8\n[mysqld]\nskip-name-resolve\nuser = mysql\nbasedir = /path-to-mysql\ndatadir = /path-to-mysql/data\nport = 3306\nserver_id = 10\nsocket = /path-to-mysql/mysql.sock\npid-file = /path-to-mysql/mysql.pid\nlog-error = /path-to-mysql/data/mysql.err\nlog-bin = /path-to-mysql/data/mysql-bin\ncharacter-set-server = utf8\n```\n\n third：初始化数据库\n\n```\nchown -R mysql.mysql /data/mysq56\n\n\n/path-to-mysql/bin/mysql_install_db --defaults-file=/etc/my.cnf --user=mysql --basedir=/data/mysql56 --datadir=/data/mysql56/data\n\n```\n\nforth：修改密码，参考mac部分\n\nfifth：配置远程连接\n\n```\nGRANT ALL PRIVILEGES ON *.* TO username@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;\nFLUSH   PRIVILEGES;\n```\n\n至此，完美结束！\n\n\n\n\n\n如果不可以进行远程连接，可以尝试一下解决方案：\n\n查看mysql置文件\n\nvi /etc/my.cnf\n\n特别要留意其中的两项：bind_address和skip_networking,bind_address一定不能为127.0.0.1，否则只能在本地连接，skip_networking一定不能出现，否则只接受unix socket而不能提供tcp socket服务，建议将bind_address和skip_networking直接都注释掉。","tags":["个人总结"],"categories":["运维"]},{"title":"在网页中确定鼠标、元素的位置","url":"/2017-04-26-在网页中确定鼠标、元素的位置/","content":"\n在需要获取鼠标相对于元素的位置的时候，首先必须确定鼠标位置、元素位置，如此才能进行计算。鼠标位置、元素位置有多种获取方式，获取的值也各不相同，有的是相对于视口的，有的是相对于文档的....在没有滚动条的时候计算会很简单，相对于文档和相对于视口取得的值相同，一旦有了滚动条就会变得麻烦起来。\n\n\n\n### 获取鼠标位置\n\n* pageX、pageY\n\n  鼠标事件的只读属性(MouseEvent.pageX ，MouseEvent.pageY)pageX和pageY返回的是相对于整个文档的坐标，以像素为单位。\n\n  This property takes into account any vertical(pageX) , horizontal(pageY)scrolling of the page. ——from  MDN \n\n  这两个属性会把滚动也计算进去。但是这两个属性只会把body的滚动计算进去，如果是body内部元素的滚动需要在pageX、pageY上叠加上滚动的值。\n\n  其实这是一个有意思的事情。\n\n* clientX、clientY\n\n  鼠标事件的只读属性clientX和clientY返回的是相对于浏览器内容区域的X、Y坐标，不包含滚动的值\n\n   clicking in the top-left corner of the client area will always result in a mouse event with a `clientX` value of 0, regardless of whether the page is scrolled . ——from MDN \n\n* screenX、screenY\n\n  鼠标事件的只读属性screenX和screenY返回的是鼠标相对于屏幕的距离。\n\n* offsetX、offsetY\n\n  和pageX、pageY类似，只有IE支持\n\n  ​\n\n### 获取DOM元素位置和尺寸大小\n\n以下内容都是DOM元素的属性\n\n* offsetWidth 和 offsetHeight：元素宽度，包括border和padding\n\n* clientWidth 和 clientHeight：元素宽度，包括padding，不包含滚动条，margin，border。如果没有CSS属性或者是inline layout box其值将会是0\n\n*  scrollWidth和scrollHeight：元素的内容区域加上内边距加上溢出尺寸，当内容正好和内容区域匹配没有溢出时，这些属性与clientWidth和clientHeight相等\n\n* offsetLeft 和 offsetTop：和已定位父容器左上角的距离。\n\n  注意：对于块级元素来讲，offsetWidth、offsetHeight、offsetLeft、offsetTop描述的是一个元素border的宽度高度以及相对于offsetParent的距离\n\n  However, for inline-level elements (such as **span**) that can wrap from one line to the next, `offsetTop`and `offsetLeft` describe the positions of the *first* border box (use [`Element.getClientRects()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getClientRects) to get its width and height), while `offsetWidth` and `offsetHeight` describe the dimensions of the *bounding*border box (use [`Element.getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect) to get its position). Therefore, a box with the left, top, width and height of `offsetLeft, offsetTop, offsetWidth` and `offsetHeight` will not be a bounding box for a span with wrapped text.\n\n  因为不知道怎么翻译，就把这段话粘贴过来了\n\n* clientTop和clientLeft返回内边距的边缘和边框的外边缘之间的水平和垂直距离，也就是左，上边框宽度\n\n* scrollLeft和scrollTop是指元素滚动条位置\n\n","tags":["个人总结"],"categories":["JavaScript"]},{"title":"三栏式布局","url":"/2017-04-20-三栏式布局/","content":"\n“总结是一个好习惯”——孙悟空\n\nThanks to[三栏布局的n种实现](https://segmentfault.com/a/1190000005721963)\n\n### 实现三栏式布局的几种方案\n\n**方案一：绝对定位**\n\n绝对定位的元素将会脱离文档流，利用绝对定位将左右两栏抽离文档流，中间栏用margin值撑开可以容纳左右栏的距离。\n\n**方案二：浮动**\n\n左栏左浮动，右栏右浮动，中间栏用margin值撑开可以容纳左右栏的距离。**浮动框不在文档的普通流中，对于文档流中的普通块框，浮动框可以当成不存在。——W3C**\n\n**方案三：浮动+负的margin**\n\n这个方案还是挺有意思的。\n\n直接看代码吧，关键代码如下：\n\n```html\n <style>\n        #main,\n        .l,\n        .r {\n            float: left;\n        }\n        \n        #main {\n            width: 100%;\n        }\n        \n        .c {\n            margin-left: 100px;\n            margin-right: 200px;\n            background-color: blue;\n        }\n        \n        .l {\n            width: 100px;\n            background-color: grey;\n            margin-left: -100%;\n        }\n        \n        .r {\n            width: 200px;\n            background-color: grey;\n            margin-left: -200px;\n        }\n    </style>\n\n\n  \t<div id=\"main\">\n        <div class=\"c\">中间内容</div>\n    </div>\n    <div class=\"l\">左边内容</div>\n    <div class=\"r\">右边内容</div>\n```\n\n上面这段代码，关键在于，main宽度是100%，c只是在宽度100%的基础上设置了margin，以便容纳左右两栏。main必须在l和r之前，**原因在于l和r中的margin-left值得选取是在有main的基础上进行的，设置了margin-left的值之后就可以使左右两栏分别置于左右**\n\nl和r中的margin-left的值的选取：**首先需要去理解的是文档流之所以会“垂直”排列在浏览器中，是因为浏览器的宽度不够宽，当然这个说法不够严谨。严谨的观点：对于宽度是100%的元素，其后的元素只能放在下一行；对于内联元素，如果当某一元素在第n行时，第n行所有元素总的宽度大于浏览器宽度时，该元素只能放在下一行。把某一行元素移动到下一行对应位置，只需要把该元素的margin-left值设置为100%即可**\n\n**方案四：利用inline-block**\n\n从segmentfault上copy来的代码如下：\n\n**但是对这段代码人就有很大疑问？**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>test_float</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        \n        .content,\n        .right,\n        .left {\n            display: inline-block;\n            font-size: 16px;\n            letter-spacing: normal;\n        }\n        \n        .box {\n            font-size: 0;  <!--  目的是为了使inline-block元素之间消除4px的空白-->\n            letter-spacing: -4px;\n            padding-left: 100px;\n            padding-right: 200px;\n        }\n        \n        .content {\n            width: 100%;\n            background-color: blue;\n        }\n        \n        .left {\n            width: 100px;\n            margin-left: -100px;\n            position: relative;\n            background-color: grey;\n            left: -100%;\n        }\n        \n        .right {\n            position: relative;\n            width: 200px;\n            margin-left: -200px;\n            left: 200px;\n            background-color: grey;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"box\">\n        <div class=\"content\">中间内容</div>\n        <div class=\"left\">左边内容</div>\n        <div class=\"right\">右边内容</div>\n    </div>\n\n</body>\n\n</html>\n```\n\n\n\n**方案五：利用calc()和inline-block特点**（方案五和方案四有很大的相似之处）\n\n代码如下，当然其中box设置font-size为0还是不太明白是何用意\n\n```Html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>test_float</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        \n        .content,\n        .right,\n        .left {\n            display: inline-block;\n            font-size: 16px;\n            letter-spacing: normal;\n        }\n        \n        .box {\n            font-size: 0;\n            letter-spacing: -4px;\n        }\n        \n        .left {\n            width: 100px;\n            background-color: grey;\n        }\n        \n        .content {\n            width: calc(100% - 300px);\n            background-color: blue;\n        }\n        \n        .right {\n            width: 200px;\n            background-color: grey;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"box\">\n        <div class=\"left\">左边内容</div>\n        <div class=\"content\">中间内容</div>\n\n        <div class=\"right\">右边内容</div>\n    </div>\n\n</body>\n\n</html>\n```\n\n\n\n**方案六：利用flex**\n\nflex是一个新东西，也是我个人觉得挺重要的一个东西，所以会新开一篇博文。\n\nLoading...\n\n\n\n\n\n","tags":["阅读整理"],"categories":["CSS"]},{"title":"Nginx+thinkphp MAC Os","url":"/2017-02-20-Nginx-thinkphp-MAC-Os/","content":"\nNginx+PHP(FastCGI)的安装和配置\n\nThanks to [实战Nginx与PHP（FastCGI）的安装、配置与优化](http://ixdba.blog.51cto.com/2895551/806622)、[Nginx配置小记](http://arccode.net/2015/02/27/Nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E8%AE%B0/)\n\n### FastCGI\n\nFastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等，同时，FastCGI也被许多脚本语言所支持，其中就有PHP。\nFastCGI是从CGI发展改进而来的。传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后结果被返回给HTTP服务器。这在处理高并发访问时，几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少被使用了。\nFastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能\n\n### Nginx+FastCGI运行原理\n\nNginx不支持对外部程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket，（这个socket可以是文件socket，也可以是ip socket）。为了调用CGI程序，还需要一个FastCGI的wrapper（wrapper可以理解为用于启动另一个程序的程序），这个wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接纳到请求，然后派生出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据发送给客户端，这就是Nginx+FastCGI的整个运作过程\n\n![140224291](/Users/spades/Downloads/140224291.png)\n\n### **spawn-fcgi与PHP-FPM**\n\n前面介绍过，FastCGI接口方式在脚本解析服务器上启动一个或者多个守护进程对动态脚本进行解析，这些进程就是FastCGI进程管理器，或者称之为FastCGI引擎， spawn-fcgi与PHP-FPM就是支持PHP的两个FastCGI进程管理器。\n下面简单介绍spawn-fcgi与PHP-FPM的异同。\n\nspawn-fcgi是HTTP服务器lighttpd的一部分，目前已经独立成为一个项目，一般与lighttpd配合使用来支持PHP，但是ligttpd的spwan-fcgi在高并发访问的时候，会出现内存泄漏甚至自动重启FastCGI的问题。\n\nNginx是个轻量级的HTTP server，必须借助第三方的FastCGI处理器才可以对PHP进行解析，因此Nginx+spawn-fcgi的组合也可以实现对PHP的解析，这里不过多讲述。\n\nPHP-FPM也是一个第三方的FastCGI进程管理器，它是作为PHP的一个补丁来开发的，在安装的时候也需要和PHP源码一起编译，也就是说PHP-FPM被编译到PHP内核中，因此在处理性能方面更加优秀；同时它在处理高并发方面也比spawn-fcgi引擎好很多，因此，推荐Nginx+PHP/PHP-FPM这个组合对PHP进行解析。\n\nFastCGI 的主要优点是把动态语言和HTTP Server分离开来，所以Nginx与PHP/PHP-FPM经常被部署在不同的服务器上，以分担前端Nginx服务器的压力，使Nginx专一处理静态请求和转发动态请求，而PHP/PHP-FPM服务器专一解析PHP动态请求\n\n### 配置\n\n由于Nginx本身不会对PHP进行解析，因此要实现Nginx对PHP的支持，其实是将对PHP页面的请求交给fastCGI进程监听的IP地址及端口。如果把php-fpm当做动态应用服务器，那么Nginx其实就是一个反向代理服务器。Nginx通过反向代理功能实现对PHP的解析，这就是Nginx实现PHP动态解析的原理\n\n* 配置PHP\n\n  * Mac系统自带了PHP和php-fpm，不用安装\n\n  * 修改php-fpm的配置文件\n\n    找到php-fpm.conf文件(笔者环境下，文件所在位置是/private/etc/)，修改其中的error_log项，否则运行时会报错，log无法输出，需要为error_log添加打印路径\n\n* 启动php-fpm ：sudo php-fpm\n\n* 配置Nginx\n\n  * 把nginx.conf文件中将PHP传递给FastCGI部分的代码取消注释\n  * 修改fastcgi_param，fastcgi_param指令指定放置PHP动态程序的主目录\n\n  ```\n  #具体配置代码\n  location ~ \\.php$ {\n              root           /Users/spades/www;\n              fastcgi_pass   127.0.0.1:9000;\n              fastcgi_index  index.php;\n              fastcgi_param  SCRIPT_FILENAME  /Users/spades/www$fastcgi_script_name;\n              include        fastcgi_params;\n          }\n  ```\n\n  ​\t/Users/spades/www是笔者放置动态文件的目录\n\n  * 修改user，确保具有读取php文件的权限\n\n  ```\n  #user 用户 用户组\n  user spades staff;\n  ```\n\n  ​","tags":["阅读整理"],"categories":["运维"]},{"title":"Chrome+Ajax:$http方式无法读取本地文件mac下解决方法","url":"/2017-02-11-Chrome-Ajax-http方式无法读取本地文件mac下解决方法/","content":"\n### 环境\n\nOSX、Chrome\n\n### 解决方法\n\n- 配置chrome的启动参数\n\n  - 命令行实现：chrome可执行文件所在位置/可执行文件 + 配置启动参数\n\n    ```bash\n    $ /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --allow-file-access-from-files\n    ```\n\n    /Applications/Google\\ Chrome.app/Contents/MacOS是chrome所在路径\n\n    Google\\ Chrome是可执行文件\n\n    --allow-file-access-from-files是启动参数\n\n  - 编写shell脚本(实际上和命令行实现无区别)\n\n    ```shell\n    #!/bin/bash\n    cd \"/Applications/Google Chrome.app/Contents/MacOS\"\n    \"/Applications/Google Chrome.app/Contents/MacOS/Chrome.old\" --allow-file-access-from-files \"$@\"\n    ```\n\n    \"$@\"将参数独立分开，独立打印","tags":["个人总结"],"categories":["JavaScript"]},{"title":"css中的居中","url":"/2017-02-08-css中的居中/","content":"\n[原文：**Centering in CSS: A Complete Guide**](https://css-tricks.com/centering-css-complete-guide/?utm_source=ourjs.com)\n\n### 水平居中\n\n* 内联元素：通过text-align属性设置其基于父元素对齐\n\n* 块级元素：当设置了宽度时，可以将margin-left和margin-right设置为auto，使其水平对齐。但宽度设置为100%时，将看不到对齐效果\n\n* 不止一个块级元素：将块级元素的display属性设置为inline-block，利用内联的性质将其设为居中\n\n  各个块级框并排排列\n\n```html\n<main>\n  <div>this is a dog</div>\n  <div>this is a cat</div>\n  <div>this is a pig</div>\n</main>\n```\n\n```css\nmain{\n  text-align: center;\n}\nmain div{\n  display: inline-block;\n  text-align: left;\n  width: 100px;\n  background-color: #bebebe;\n  padding: 5px;\n  margin:20px auto;\n}\n```\n\n\n\n### 垂直居中\n\n* 内联元素\n\n  * 如果是单行：可以通过设置padding-top、padding-bottom为相同的值，实现垂直居中；因为某种原因padding没有办法用的时候，将line-height设置为height也可以实现居中效果\n  * 多行：可以设置padding-top和padding-bottom值相等；如果不行，将display设置为table-cell，vertical-align属性设置为middle实现垂直居中\n\n* 块级元素\n\n  * 如果知道元素高度：可以根据具体的值进行设置（不能适用多种设备，太过绝对化）\n  * 不知道元素高度：设置其高度为父元素高度的一半，再将其上移自身高度的一半（利用transform性质）\n\n  ```css\n  selector{\n    top: 50%;\n    transform: translateY(-50%);\n  }\n  ```\n\n\n\n### 同时设置水平、垂直居中\n\n* 如果知道具体的宽和高：通过设置具体的值使其实现居中效果\n* 不知道具体宽和高：通过transform性质进行设置","tags":["阅读整理"],"categories":["CSS"]},{"title":"about","url":"/about/index.html"}]