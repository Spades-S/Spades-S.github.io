[{"title":"Webpack热更新过程中发生了什么","url":"/2018-09-27-Webpack热更新过程中发生了什么/","content":"\nWebpack HMR 或许是Webpack提供的最有用的功能之一，使用HMR的好处在于，能够在运行时更新各个模块，无需进行完全刷新，避免因完全刷新带来的状态丢失。使用HMR能够极大提升开发人员的开发效率。\n\n* 那Webpack是用什么机制实现了HMR呢？\n\n在研究原理之前，我们先看一下表象，顺便猜测一下原理。本文选取使用了HMR的工程[MusicHub](https://github.com/Spades-S/musichub)作为观测工程。\n\n![ musichub](https://i.loli.net/2018/09/27/5bac50e56a378.png)\n当浏览器在请求页面的时候都请求了哪些内容，我们从dev-tools的network面板中可以看到，浏览器在请求页面的时候请求了html文件，des.js，webpack打包生成的文件，data:font... 字体文件，以及info?t=... 和 websocket，在这5个文件中，需要注意的是后两个，info?t=... 和 websocket，查看这两个请求，\n\n![ info?t=](https://i.loli.net/2018/09/27/5bac5671aef52.png)\n\ninfo?=... 是一个常规请求，暂时跳过，看看websocket\n\n![ websocket ](https://i.loli.net/2018/09/27/5bac56dca4776.png)\n我们看到，这个请求建立了websocket通信，到这儿我们可以大胆地进行猜测，HMR的实现是基于websocket的。\n\n* 通过源码了解HMR实现原理\n\n在开发环境中，是使用webpack-dev-server提供开发环境下的服务的，我们首先看webpack-dev-server里有什么。\n\n``` js\n// webpack-dev-server/bin/webpack-dev-server.js\nconst Server = require('../lib/Server');\nprocessOptions(wpOpt);\nfunction processOptions(webpackOptions) {\n\t// ...\n\tif (options.port != null) {\n    startDevServer(webpackOptions, options);\n    return;\n  }\n\n  portfinder.basePort = DEFAULT_PORT;\n  portfinder.getPort((err, port) => {\n    if (err) throw err;\n    options.port = port;\n    startDevServer(webpackOptions, options);\n  });\n}\nfunction startDevServer(webpackOptions, options) {\n  // ...\n  let compiler;\n  try {\n    compiler = webpack(webpackOptions);\n  } catch (e) {\n    // ...\n  }\n  // ...\n  let server;\n  try {\n    server = new Server(compiler, options);\n  } catch (e) {\n    const OptionsValidationError = require('../lib/OptionsValidationError');\n    if (e instanceof OptionsValidationError) {\n      console.error(colorError(options.stats.colors, e.message));\n          process.exit(1); // eslint-disable-line\n    }\n    throw e;\n  }\n  // ...\n}\n```\n以上就是webpack-dev-server/bin/webpack-dev-server.js文件中的关键部分代码，核心工作是startDevServer，这里面最重要的是 `compiler` 和 `server`，compiler是返回的webpack Compiler 实例。我们再来看看`server`，`server` 是调用new Server()返回的对象，Server是从webpack-dev-server/lib/Server.js 文件中导出的。\n\n``` js\n// webpack-dev-server/lib/Server.js \nfunction Server(compiler, options) {\n\t// ...\n\tcompiler.plugin('compile', invalidPlugin);\n    compiler.plugin('invalid', invalidPlugin);\n    compiler.plugin('done', (stats) => {\n        this._sendStats(this.sockets, stats.toJson(clientStats));\n        this._stats = stats;\n    });\n\n\n\tconst app = this.app = new express(); // eslint-disable-line\n\n\t// ...\n\tapp.get('/webpack-dev-server/*', (req, res) => {\n        res.setHeader('Content-Type', 'text/html');\n        fs.createReadStream(path.join(__dirname, '..', 'client', 'live.html')).pipe(res);\n    });\n\n\t// a series of routers\n\n\t// ... \n\n}\n\nServer.prototype._sendStats = function(sockets, stats, force) {\n\t// ... \n    this.sockWrite(sockets, 'hash', stats.hash);\n    if (stats.errors.length > 0) {\n\t\t this.sockWrite(sockets, 'errors', stats.errors); \n\t} else if (stats.warnings.length > 0) {\n\t\tthis.sockWrite(sockets, 'warnings', stats.warnings); \n\t} else { \n\t\tthis.sockWrite(sockets, 'ok'); \n\t}\n};\n\nmodule.exports = Server;\n```\n\nwebpack-dev-server/lib/Server.js 文件核心就是导出Server函数，在Server函数中我们可以看到 监听了compiler实例的各个生命周期，当编译完成时，调用this._sendStats(...)。在sendStats函数中，通过websocket向浏览器发送了几个消息：分别是 hash消息，内容是编译新生成模块的hash值；ok 消息。我们可以在浏览器上通过dev-tools进行验证。\n\n![websocket-messages](https://i.loli.net/2018/10/07/5bb974e05f08e.jpg)\n\n\n上面我们提到了webpack-dev-server通过websocket向服务器发送了`hash`消息和`ok`消息，但是，websocket是在什么时候建立的呢？我们需要看一下webpack-dev-server/client/index.js。\n\n``` js\n// webpack-dev-server/client/index.js\nvar socket = require('./socket');\n\n// ... \n\nvar socketUrl = url.format({\n    protocol: protocol,\n    auth: urlParts.auth,\n    hostname: hostname,\n    port: urlParts.port,\n    pathname: urlParts.path == null || urlParts.path === '/' ? '/sockjs-node' : urlParts.path\n});\n\n\nsocket(socketUrl, onSocketMsg);\n\n// ... \n\n```\n在 webpack-dev-server/client/index.js 中调用了socket函数，该函数是从 webpack-dev-server/client/socket.js下引入的，我们到webpack-dev-server/client/socket.js下看看：\n\n``` js\n// webpack-dev-server/client/socket.js\nvar SockJS = require('sockjs-client/dist/sockjs');\n\n// ...\n\nvar socket = function initSocket(url, handlers) {\n  sock = new SockJS(url);\n\n  // ...\n  \n}\n\n// ... \n```\n我们可以看到是在webpack-dev-server/client/socket.js 中建立了websocket连接。不过上面👆看到的这两个文件都是websocket client， 那websocket server呢？websocket server是在webpack-dev-server/lib/Server.js 中创建的：\n\n``` js\n// webpack-dev-server/lib/Server.js\n\n// ...\n\nServer.prototype.listen = function(port, hostname, fn) {\n    this.listenHostname = hostname;\n    // eslint-disable-next-line\n\n    const returnValue = this.listeningApp.listen(port, hostname, (err) => {\n        const sockServer = sockjs.createServer({\n            // Use provided up-to-date sockjs-client\n            sockjs_url: '/__webpack_dev_server__/sockjs.bundle.js',\n            // Limit useless logs\n            log(severity, line) {\n                if (severity === 'error') {\n                    log(line);\n                }\n            }\n        });\n\n        sockServer.on('connection', (conn) => {\n            if (!conn) return;\n            if (!this.checkHost(conn.headers)) {\n                this.sockWrite([conn], 'error', 'Invalid Host header');\n                conn.close();\n                return;\n            }\n            this.sockets.push(conn);\n\n            conn.on('close', () => {\n                const connIndex = this.sockets.indexOf(conn);\n                if (connIndex >= 0) {\n                    this.sockets.splice(connIndex, 1);\n                }\n            });\n\n            if (this.clientLogLevel) { this.sockWrite([conn], 'log-level', this.clientLogLevel); }\n\n            if (this.progress) { this.sockWrite([conn], 'progress', this.progress); }\n\n            if (this.clientOverlay) { this.sockWrite([conn], 'overlay', this.clientOverlay); }\n\n            if (this.hot) this.sockWrite([conn], 'hot');\n\n            if (!this._stats) return;\n            this._sendStats([conn], this._stats.toJson(clientStats), true);\n        });\n\n        sockServer.installHandlers(this.listeningApp, {\n            prefix: '/sockjs-node'\n        });\n\n        if (fn) {\n            fn.call(this.listeningApp, err);\n        }\n    });\n\n    return returnValue;\n};\n\n// ... \n\n```\n\n从上面👆的代码中可以看到，在建立了websocket连接之后，会立即给浏览器端的websocket client发送消息，消息类型可能是`log-lverl`，`progress`，`overlay`，`hot`，我们通过dev tools来验证下：\n\n![websocket-messages](https://i.loli.net/2018/10/07/5bb9755c90cde.jpg)\n\n\n我们成功找到了 `log-level` 和 `hot` 消息。\n\nwebpack-dev-server 在compiler编译完成之后会向浏览器发送`hash` 和 `ok` 消息，那浏览器在接收到这两个消息之后会执行什么操作呢？我们来看 webpack-dev-server/client/index.js：\n\n``` js\n// webpack-dev-server/client/index.js\n\n// ...\n\nvar onSocketMsg = {\n    hot: function hot() {\n        _hot = true;\n        log.info('[WDS] Hot Module Replacement enabled.');\n    },\n    invalid: function invalid() {\n        log.info('[WDS] App updated. Recompiling...');\n        // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.\n        if (useWarningOverlay || useErrorOverlay) overlay.clear();\n        sendMsg('Invalid');\n    },\n    hash: function hash(_hash) {\n        currentHash = _hash;\n    },\n\n\t// ...\n\n\tok: function ok() {\n        sendMsg('Ok');\n        if (useWarningOverlay || useErrorOverlay) overlay.clear();\n        if (initial) return initial = false; // eslint-disable-line no-return-assign\n        reloadApp();\n    },\n\n\t// ...\n}\n\n// ...\n\nsocket(socketUrl, onSocketMsg);\n\n// ...\n\nfunction reloadApp() {\n\n\t//...\n\n    if (_hot) {\n        log.info('[WDS] App hot update...');\n        // eslint-disable-next-line global-require\n        var hotEmitter = require('webpack/hot/emitter');\n        hotEmitter.emit('webpackHotUpdate', currentHash);\n        if (typeof self !== 'undefined' && self.window) {\n            // broadcast update to window\n            self.postMessage('webpackHotUpdate' + currentHash, '*');\n        }\n    } else {\n        var rootWindow = self;\n        // use parent window for reload (in case we're in an iframe with no valid src)\n        var intervalId = self.setInterval(function() {\n            if (rootWindow.location.protocol !== 'about:') {\n                // reload immediately if protocol is valid\n                applyReload(rootWindow, intervalId);\n            } else {\n                rootWindow = rootWindow.parent;\n                if (rootWindow.parent === rootWindow) {\n                    // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways\n                    applyReload(rootWindow, intervalId);\n                }\n            }\n        });\n    }\n\n    function applyReload(rootWindow, intervalId) {\n        clearInterval(intervalId);\n        log.info('[WDS] App updated. Reloading...');\n        rootWindow.location.reload();\n    }\n}\n\n```\n浏览器在接收到 `hash` 消息后会将hash值放到currentHash中存起来，在接收到 `ok` 消息之后，会执行 `reloadApp` 函数。 在 `realoadApp` 函数中，有一个 `if/else`，条件是 `_hot` ,也就是是否支持热重载，如果支持，进入 `if` 分支， 否则进入 `else` 分支，先来看一下 `else` 分支，`else` 分支中核心就是 `applyReload` 函数， 而 `applyReload` 函数的功用就是重载页面。再来看看 `if` 分支，也就是可以进行热重载，在 `if` 分支中会通过 `hotEmitter` 发射一个 `webpackHotUpdate` 事件，内容是收到 `hash` 消息时保存的hash值。\n\n先来看一下 hotEmitter，它是从 webpack/hot/emitter.js 中导出的：\n\n``` js\n// webpack/hot/emitter.js\n\nvar EventEmitter = require(\"events\");\nmodule.exports = new EventEmitter();\n\n```\nhotEmitter 本质是 EventEmitter的一个实例，EventEmitter提供了异步事件驱动架构，[ 这里可以对比浏览器中的点击事件，本质上是一致的，只不过EventEmitter事件是由代码触发，点击事件是由鼠标触发 ]。\n那 `webpackHotUpdate` 事件监听在哪儿呢？在 webpack/hot/dev-server.js 中：\n\n``` js \n// webpack/hot/dev-server.js\nif (module.hot) {\n\n\tvar check = function check() {\n        module.hot.check(true).then(function(updatedModules) {\n            if (!updatedModules) {\n                log(\"warning\", \"[HMR] Cannot find update. Need to do a full reload!\");\n                log(\"warning\", \"[HMR] (Probably because of restarting the webpack-dev-server)\");\n                window.location.reload();\n                return;\n            }\n\n            if (!upToDate()) {\n                check();\n            }\n\n            require(\"./log-apply-result\")(updatedModules, updatedModules);\n\n            if (upToDate()) {\n                log(\"info\", \"[HMR] App is up to date.\");\n            }\n\n        }).catch(function(err) {\n            var status = module.hot.status();\n            if ([\"abort\", \"fail\"].indexOf(status) >= 0) {\n                log(\"warning\", \"[HMR] Cannot apply update. Need to do a full reload!\");\n                log(\"warning\", \"[HMR] \" + err.stack || err.message);\n                window.location.reload();\n            } else {\n                log(\"warning\", \"[HMR] Update failed: \" + err.stack || err.message);\n            }\n        });\n    };\n\n\tvar hotEmitter = require(\"./emitter\");\n    hotEmitter.on(\"webpackHotUpdate\", function(currentHash) {\n        lastHash = currentHash;\n        if (!upToDate() && module.hot.status() === \"idle\") {\n            log(\"info\", \"[HMR] Checking for updates on the server...\");\n            check();\n        }\n    });\n}\n```\n\n在监听到 `webpackHotUpdate` 事件之后，会调用 `check` 函数，而 `check` 函数内部会调用 `module.hot.check` 函数。 我们需要看下 webpack/lib/HotModuleReplacement.runtime.js：\n\n``` js\n// webpack/lib/HotModuleReplacement.runtime.js\n\n// ... \n\nfunction hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars\n        var hot = {\n            // private stuff\n            _acceptedDependencies: {},\n\n            // Module API\n            active: true,\n            accept: function(dep, callback) {\n                if (typeof dep === \"undefined\")\n                    hot._selfAccepted = true;\n                else if (typeof dep === \"function\")\n                    hot._selfAccepted = dep;\n                else if (typeof dep === \"object\")\n                    for (var i = 0; i < dep.length; i++)\n                        hot._acceptedDependencies[dep[i]] = callback || function() {};\n                else\n                    hot._acceptedDependencies[dep] = callback || function() {};\n            },\n\n\t\t\t// ...\n\n            // Management API\n            check: hotCheck,\n            apply: hotApply,\n\n\t\t\t// ... \n           \n        };\n        hotCurrentChildModule = undefined;\n        return hot;\n    }\n\n\n\tfunction hotCheck(apply) {\n\n\t\t// ...\n\n        return hotDownloadManifest(hotRequestTimeout).then(function(update) {\n            if (!update) {\n                hotSetStatus(\"idle\");\n                return null;\n            }\n            hotRequestedFilesMap = {};\n            hotWaitingFilesMap = {};\n            hotAvailableFilesMap = update.c;\n            hotUpdateNewHash = update.h;\n\n            hotSetStatus(\"prepare\");\n            var promise = new Promise(function(resolve, reject) {\n                hotDeferred = {\n                    resolve: resolve,\n                    reject: reject\n                };\n            });\n            hotUpdate = {};\n            /*foreachInstalledChunks*/\n            { // eslint-disable-line no-lone-blocks\n                /*globals chunkId */\n                hotEnsureUpdateChunk(chunkId);\n            }\n            if (hotStatus === \"prepare\" && hotChunksLoading === 0 && hotWaitingFiles === 0) {\n                hotUpdateDownloaded();\n            }\n            return promise;\n        });\n    }\n\n```\n\n`module.hot.check` 就是 `hotCreateModule` 中的 `hot.check`，指向该文件中 `hotCheck` 函数，`hotCheck` 函数会调用 `hotDownloadManifest` 函数，该函数可以在 webpack/lib/JsonpMainTemplate.runtime.js 中找到：\n\n``` js\n// webpack/lib/JsonpMainTemplate.runtime.js\n\n// ...\n\nfunction hotDownloadManifest(requestTimeout) { // eslint-disable-line no-unused-vars\n\trequestTimeout = requestTimeout || 10000;\n\treturn new Promise(function(resolve, reject) {\n\t\tif (typeof XMLHttpRequest === \"undefined\")\n\t\t\treturn reject(new Error(\"No browser support\"));\n\t\ttry {\n\t\t\tvar request = new XMLHttpRequest();\n\t\t\tvar requestPath = $require$.p + $hotMainFilename$;\n\t\t\trequest.open(\"GET\", requestPath, true);\n\t\t\trequest.timeout = requestTimeout;\n\t\t\trequest.send(null);\n\t\t} catch (err) {\n\t\t\treturn reject(err);\n\t\t}\n\t\trequest.onreadystatechange = function() {\n\t\t\tif (request.readyState !== 4) return;\n\t\t\tif (request.status === 0) {\n\t\t\t\t// timeout\n\t\t\t\treject(new Error(\"Manifest request to \" + requestPath + \" timed out.\"));\n\t\t\t} else if (request.status === 404) {\n\t\t\t\t// no update available\n\t\t\t\tresolve();\n\t\t\t} else if (request.status !== 200 && request.status !== 304) {\n\t\t\t\t// other failure\n\t\t\t\treject(new Error(\"Manifest request to \" + requestPath + \" failed.\"));\n\t\t\t} else {\n\t\t\t\t// success\n\t\t\t\ttry {\n\t\t\t\t\tvar update = JSON.parse(request.responseText);\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve(update);\n\t\t\t}\n\t\t};\n\t});\n}\n\n// ...\n\n```\n`hotDownloadManifest` 函数通过Ajax去请求更新文件列表。\n![hotDownloadManifest](https://i.loli.net/2018/10/07/5bb975a8f1574.jpg)\n\n\nAjax请求返回会，会调用 `hotEnsureUpdateChunk` 函数，`hotEnsureUpdateChunk` 函数核心内容是调用 `hotDownloadUpdateChunk` 函数。\n\n``` js\n// webpack/lib/HotModuleReplacement.runtime.js\n\n// ...\n\nfunction hotEnsureUpdateChunk(chunkId) {\n\tif (!hotAvailableFilesMap[chunkId]) {\n\t\thotWaitingFilesMap[chunkId] = true;\n\t} else {\n\t\thotRequestedFilesMap[chunkId] = true;\n\t\thotWaitingFiles++;\n\t\thotDownloadUpdateChunk(chunkId);\n\t}\n}\n\n// ...\n\n```\n\n`hotDownloadUpdateChunk` 函数可以在 webpack/lib/JsonpMainTemplate.runtime.js 中找到：\n\n``` js\n// webpack/lib/JsonpMainTemplate.runtime.js\n\nfunction hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars\n\tvar head = document.getElementsByTagName(\"head\")[0];\n\tvar script = document.createElement(\"script\");\n\tscript.type = \"text/javascript\";\n\tscript.charset = \"utf-8\";\n\tscript.src = $require$.p + $hotChunkFilename$;\n\t$crossOriginLoading$;\n\thead.appendChild(script);\n}\n\n```\n\n\n`hotDownloadUpdateChunk` 函数使用JSONP的方式来下载更新模块内容。\n\n![hotDownloadUpdateChunk](https://i.loli.net/2018/10/07/5bb976012e789.jpg)\n\n这里我们可以关注下，Manifest文件名和更新部分文件名都是用上一次的hash值来拼接的。\n![filename-hash](https://i.loli.net/2018/10/07/5bb976db1876c.jpg)\n\n更新部分内容下载完成之后，会立即执行。js文件中包含`webpackHotUpdate`的函数，我们可以在webpack编译后的文件中找到该函数：\n\n![wepack compiled](https://i.loli.net/2018/10/07/5bb9870963df2.jpg)\n\n可以看到，该函数核心内容就是调用 `hotAddUpdateChunk` 函数，可以在webpack/lib/HotModuleReplacement.runtime.js 文件中找到 hotAddUpdateChunk 函数：\n\n``` js \n// webpack/lib/HotModuleReplacement.runtime.js\nfunction hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars\n    if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\n        return;\n    hotRequestedFilesMap[chunkId] = false;\n    for (var moduleId in moreModules) {\n        if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n            hotUpdate[moduleId] = moreModules[moduleId];\n        }\n    }\n    if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {\n        hotUpdateDownloaded();\n    }\n}\n\n```\n\n`hotAddUpdateChunk` 函数的功能是将JSONP 方式下载的js文件中modules，绑定到hotUpdate上，hotUpdate 会在 `hotApply` 函数中被用到， 然后执行 `hotUpdateDownloaded` 函数。\n\n\n\n接下来我们来看一下 `hotUpdateDownloaded` 函数：\n\n``` js \n// webpack/lib/HotModuleReplacement.runtime.js\n\nfunction hotUpdateDownloaded() {\n    hotSetStatus(\"ready\");\n    var deferred = hotDeferred;\n    hotDeferred = null;\n    if (!deferred) return;\n    if (hotApplyOnUpdate) {\n        // Wrap deferred object in Promise to mark it as a well-handled Promise to\n        // avoid triggering uncaught exception warning in Chrome.\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=465666\n        Promise.resolve().then(function() {\n            return hotApply(hotApplyOnUpdate);\n        }).then(\n            function(result) {\n                deferred.resolve(result);\n            },\n            function(err) {\n                deferred.reject(err);\n            }\n        );\n    } else {\n\n       // ...\n\n    }\n}\n```\n\nhotUpdateDownloaded函数中核心部分是 hotApply，我们转到hotApply，看看它实现了什么功能：\n\n``` js\n// webpack/lib/HotModuleReplacement.runtime.js\nfunction hotApply() {\n    // ...\n    var idx;\n    var queue = outdatedModules.slice();\n    while(queue.length > 0) {\n        moduleId = queue.pop();\n        module = installedModules[moduleId];\n        // ...\n        // remove module from cache\n        delete installedModules[moduleId];\n        // when disposing there is no need to call dispose handler\n        delete outdatedDependencies[moduleId];\n        // remove \"parents\" references from all children\n        for(j = 0; j < module.children.length; j++) {\n            var child = installedModules[module.children[j]];\n            if(!child) continue;\n            idx = child.parents.indexOf(moduleId);\n            if(idx >= 0) {\n                child.parents.splice(idx, 1);\n            }\n        }\n    }\n    // ...\n    // insert new code\n    for(moduleId in appliedUpdate) {\n        if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\n            modules[moduleId] = appliedUpdate[moduleId];\n        }\n    }\n    // ...\n}\n\n```\nHMR 主要分为三个阶段：第一阶段，找出过期的模块和过期依赖；第二阶段，从缓存中删除过期模块、过期依赖；第三阶段，将新的模块添加到modules中。在更新时，如果出现错误，会回退到刷新页面。\n\n![HMR fallback](https://i.loli.net/2018/10/07/5bb9be8a4ca67.jpg)\n\n\n到这里webpack HMR 已经完成了热更新使命，那是如何实现UI无刷新更新的呢？\n\n对于Vue.js，是通过 vue-hot-reload-api 来实现UI无刷新更新，vue-hot-reload-api 通过获取组件的render函数，重新render组件，继而实现无刷新更新。—— [Webpack 热更新原理分析](https://zhuanlan.zhihu.com/p/30623057)\n\n\n\n### 总结\n\n![图片来自 Webpack HMR 原理解](https://i.loli.net/2018/10/07/5bb9befc43512.jpg)\n\n\n1. 页面首次打开，服务端和浏览器通过websocket建立通信；\n2. Webpack监听到文件变化，编译文件，webpack-dev-server 监听 wepack编译器 done 事件，编译完成时，webpack-dev-server 通过websocket想浏览器发送 `hash` 和 `ok` 消息；\n3. 浏览器接收到 `ok` 消息，利用Ajax向服务端请求更新文件列表；\n4. 浏览器端拿到更新列表后，利用JSONP向服务端请求更新的模块，请求完成后，更新modules，如果出现错误会回退到刷新页面；\n5. 对于Vue.js，利用vue-hot-reload-api实现UI无刷新更新。\n \n\n\n\n\n\n\n\n\n### reference\n* [Webpack HMR 原理解析](https://zhuanlan.zhihu.com/p/30669007)\n\n* [Webpack 热更新原理分析](https://zhuanlan.zhihu.com/p/30623057)\n \n\n\n\n\n\n\n\n\n\n\n","tags":["个人总结"],"categories":["Webpack"]},{"title":"浏览器中的EventLoop","url":"/2018-05-26-浏览器中的EventLoop/","content":"\n**EventLoop是用户代理为协调事件(event)、用户交互(user interaction)、脚本(script)、渲染(rendering)、网络(networking)等而采取的机制**。EventLoop是在[HTML-SPEC](https://html.spec.whatwg.org/#event-loop)中定义的，而非ECMAScript中定义的，也就是说**EventLoop实质上是由用户代理实现的**。\n\n### Specification\n\n>我们来看看标准是怎么解释EventLoop的，翻译可能有不对之处，建议直接看 [Spec](https://html.spec.whatwg.org/multipage/webappapis.html#generic-task-sources)。\n\n* 定义\n\n  事件循环(EventLoop)是用户代理为协调事件(event)、用户交互(user interaction)、脚本(script)、渲染(rendering)、网络(networking)等而采取的机制。事件循环可以分为两类，一类是浏览器上下文(browsing context)事件循环，一类是worker事件循环。browsing context EventLoop、worker EventLoop 分别由各自的处理模型来管理EventLoop的生命周期。\n\n  **下面所有内容均是关于browsing context EventLoop，worker EventLoop我们暂时忽略它**。\n\n* Task queue in browsing context EventLoop\n\n  * 一个EventLoop会有一个或者多个`task queue`。`task queue` 是一个有序的任务列表(an ordered list of tasks)。这些task是负责实现`Event`、`Parsing`、`Callbacks`、`Using a resource`、`Reacting  to DOM manipulation`的算法。\n\n    所有的`task`都是来自特定的`task source`，来自相同的`task source`并且是针对特定的`EventLoop`的的任务会被添加到相同的`task queue`，来自不同的`task source`会被放入不同的`task queue`。\n\n  * **每一个EventLoop有一个Microtask queue**\n\n* Task sources in browsing context EventLoop\n\n  * Generic task sources\n\n    * DOM manipulation(DOM 操作)\n    * User Interaction(用户交互)：所有响应用户输入的event都将会被加入用户交互事件所在队列\n    * Networking(网络)：触发网络请求的操作\n    * History traversal(历史记录相关操作)：history.back()及其类似操作 \n\n  * Microtask sources(**V8引擎中** )\n\n    * process.nextTick, Promises, Object.observe, MutationObserver\n\n  * 关于Macrotask和Microtask\n\n    * Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.  — [Promise A+](https://promisesaplus.com/)\n\n    * V8中Macrotask 和 Microtask包含的任务：\n\n      macrotasks: script(整体代码),setTimeout, setInterval, setImmediate, I/O, UI rendering\n      microtasks: process.nextTick, Promises, Object.observe, MutationObserver\n\n      ​\n\n* Processing model in browsing context EventLoop\n\n  * 用户代理从从全部任务队列中挑出一个任务队列，选择其中最老的任务最为`EventLoop`的`oldestTask`。如果挑不出任务，将去直接跳转到microtasks 步骤\n\n  * 将EventLoop当前执行任务置为`oldestTask`\n\n  * 运行`oldestTask`\n\n  * 将`EventLoop`当前执行任务置为null\n\n  * 将`oldestTask`从其`task queue`中移除\n\n  * 执行Microtask任务：进入Microtask检查点\n\n  * 更新视图：在更新视图时会判断是否有需要，如果当前视图没有影响将不会更新\n\n    更新视图顺序：\n\n    * 会resize\n    * srcoll\n    * media query  and report changes\n    * update animations adn send events\n    * fullscreen\n    * animation frame callbacks (对应于 requestAnimationFrame)\n    * 更新视图、用户接口、浏览器上下文\n\n* 执行Microtask任务：进行Microtask检查点\n\n  * 首先将进入Microtask检查点标志置为true\n  * 当EventLoop的Microtask queue不为空时：\n    * 将队列中最老的Microtask任务置为`oldestMicrotask`\n    * 将EventLoop当前执行任务设置为`oldestMicrotask`\n    * 运行`oldestMicrotask`\n    * 将EventLoop当前执行任务置为null\n    * 从Microtask queue中移除`oldestMicrotask`\n  * 通知EventLoop对应的环境设置对象(environment settings object) rejected promise信息\n  * 清空Indexed Database 事务\n  * 将进入Microtask检查点标志置为false\n\n\n\n\n### Practice\n\n这里推荐大家去看session stack上的文章：[How JavaScript works: Event loop and the rise of Async programming + 5 ways to better coding with async/await](https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5)，讲的很好。\n\n\n### Reference\n* [什么是浏览器的事件循环（Event Loop）？](https://segmentfault.com/a/1190000010622146)\n* [从event loop规范探究javaScript异步及浏览器更新渲染时机](https://github.com/aooy/blog/issues/5)\n* [[JavaScript] Macrotask Queue和Microtask Queue](https://www.jianshu.com/p/3ed992529cfc)\n* [Primise A+](https://promisesaplus.com/)\n* [HTML-SPCE-EventLoop](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop)\n* [Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n* [How JavaScript works: Event loop and the rise of Async programming + 5 ways to better coding with async/await](https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5)\n\n","tags":["个人总结"],"categories":["Browser"]},{"title":"重读红宝书-面向对象的程序设计","url":"/2018-05-03-重读红宝书-面向对象的程序设计/","content":"\n>每次读红宝书都会新的体会，这算是个人成长的一个印证吧。\n\n在JavaScript中，面向对象程序设核心问题在于如何创建对象、实现继承。\n\n#### 创建对象\n\n* 【**创建单个对象**】最基础的创建对象的方式，使用new 语法：new Object()，这种方式很繁琐，可以用更简洁的方式去创建对象：**对象字面量**。\n\n```javascript\n//No.1  new 语法\nlet obj = new Object()\nobj.key = value\n\n//No.2 字面量方式\nlet obj = {\n  key: name\n}\n```\n\n\n* 【**创建多个结构相同对象**】如果只是要创建单个对象，使用字面量方式已经足够了，但是当需要创建许多结构相同的对象时，采用字面量方式会造成许多重复代码。为了解决上述问题，引出了若干种创建对象的模式：\n\n  * **工厂模式**：抽象了创建对象的过程，将其封装在函数里，暴露出相应接口\n\n  ```javascript\n  function createPerson(name, age){\n    const person = {\n      name,\n      age\n    }\n    return person\n  }\n  // 工厂模式的本质是在函数内部创建对象，为其设置相应的属性，最后返回该对象\n  ```\n\n  * **构造函数模式**：工厂模式解决了重复代码的问题，但是**没有解决对象识别的问题** ，由此构造函数模式应运而生\n\n  ```javascript\n  function Person(name,age){\n    this.name = name\n    this.age = age\n    this.sayName = function(){\n      console.log(this.name)\n    }\n  }\n  const Allen = new Person('Allen', 22)\n  ```\n\n  利用构造函数模式创建对象，首先需要编写一个构造函数，然后用new操作符调用构造函数，使用new操作符调用方可创建实例。使用new操作符调用构造函数生成实例会经历四个步骤：\n\n  a. 创建一个新对象\n\n  b. 将构造函数作用域赋给新对象，此后this指向该新对象\n\n  c. 执行构造函数中的代码\n\n  d. 返回新对象\n\n  **构造函数模式的缺点：每创建一个新的实例就需要重写一遍实例方法，如果将该方法提到全局环境里又会污染全局环境。**\n\n   **— 我们现在来思考一个问题为什么使用构造函数模式可以解决对象识别问题？**\n\n    **— 如何实现对象识别，这里的对象识别更加清晰的解释是：如何判断一个实例是否属于某个“类”。最常见的方式是使用instanceof操作符: 实例 instanceof 类，instanceof实际上做的事是，判断【实例的原型链上】是否存在【类的prototype属性】。prototype属性又是怎么来的呢？只要创建了一个新函数，就会为该函数创建一个prototype属性。而对于每一个使用new方法创建的实例对象上也就是利用构造函数模式创建的实例对象，会有一个[[prototype]]内部属性，指向构造函数的原型对象，实例上就具备了类的prototype属性，这个属性在chrome浏览器中表现为：`__proto__` 属性。由于工厂模式只是简单的函数调用，不会有指向函数名的[[prototype]]属性，因而无法识别对象类型。**\n\n  ​\n\n  * **原型模式**：将实例共享的属性放在构造函数的prototype属性上，原型模式的**优点在于对于实例需要的方法我们只需要创建一次，同时又不会污染全局环境，缺点是原型链上的数据属性将会被所有实例共享**\n\n  ```javascript\n  function Person(){\n  }\n  Person.prototype.name = 'Allen'\n  Person.prototype.age = 22\n  Person.prototype.sayName = function(){\n    console.log(this.name)\n  }\n  ```\n\n\n    <img src=\"./img-1.png\" width=\"700px\">  左图来自《JavaScript高级程序设计》\n\n  * **组合使用构造函数和原型模式**：组合的方式，将无需共享的属性放在构造函数里，需要共享的方法放在构造函数的prototype属性上\n\n  ```javascript\n  function Person(name, age){\n    this.name = name\n    this.age = age\n  }\n  Person.prototype.sayName = function(){\n    console.log(this.name)\n  }\n  ```\n\n\n\n#### “类”的继承\n\n标题上的类是加了引号的，本质上JavaScript中是没有类继承的，所谓的类继承只是通过原型链或者其他方式关联起来多个相似对象。即使在ES 6 中出现了类声明，也只是一个语法糖，其本质依然是原型链关联相似对象，并没有实现类声明。\n\n* **ES 5 中的“类的继承”方式**\n\n  * **原型链**：关键在于让子类的原型链上包含父类的prototype属性\n\n  ```javascript\n  function SuperType(){\n   \tthis.name = 'super'\n  }\n  SuperType.prototype.getSuperValue = function(){\n   \tconsole.log(this.name)\n  }\n  function SubType(){\n    \tthis.name = 'sub'\n  }\n  SubType.prototype = new SuperType()\n  SubType.prototype.getSubValue = function(){\n    \tconsole.log('hello')\n  }\n  ```\n\n  <img src=\"img-2.png\" width=\"700px\"> 左图来自《JavaScript高级程序设计》\n\n  上图非常清晰地指明了是通过何种方式让子类原型链上包含父类的prototype属性：将SubType.prototype值设置为 new SuperType() ，也就是SuperType的实例，该实例上存在[[prototype]]属性，该属性指向SuperType.prototype，从而达到了让子类原型链上包含父类的prototype属性的目的\n\n  **使用上述方式实现“类”继承的缺点在于父类构造函数内的所有属性将会变成子类的共享属性**\n\n  * **借用构造函数**\n\n  ```javascript\n  function SuperType(){\n    \tthis.value = 'Super'\n  }\n  function SubType(){\n    \tSuperType.call(this)\n  }\n  ```\n\n  借用构造函数实际上是在子类构造函数内部调用父类的构造函数，并将this显示绑定到新生成对象上，在使用new 方式创建子类实例时会在新生成的对象上设置父类构造函数里的所有属性。\n\n  **借用构造函数方式的缺点：要想实现继承父类的方法必须在构造函数内定义，从而要么无法实现函数复用要么污染全局环境**\n\n  * **组合继承**：利用构造函数方式实现属性的继承，利用原型链方式实现方法的继承\n\n  ```javascript\n  function SuperType(name){\n    \tthis.name = name\n  }\n  SuperType.prototype.sayName = function(){\n    \tconsole.log(this.name)\n  }\n  function SubType(name, age){\n    //继承SuperType属性, 同时覆盖SubType.prototype上的对应属性\n    SuperType.call(this, name) \n    this.age = age\n  }\n\n  // 继承SuperType方法\n  SubType.prototype = new SuperType()\n  SubType.prototype.sayAge = function(){\n    \tconsole.log(this.age)\n  }\n  ```\n\n  * **寄生组合式继承**\n\n  ```javascript\n  function SuperType(name){\n    \tthis.name = name\n  }\n  SuperType.prototype.sayName = function(){\n    \tconsole.log(this.name)\n  }\n  function SubType(name, age){\n    //继承SuperType属性\n    SuperType.call(this, name) \n    this.age = age\n  }\n\n  // 继承SuperType方法\n  SubType.prototype = new Object(SuperType.prototype)\n  SubType.prototype.sayAge = function(){\n    \tconsole.log(this.age)\n  }\n  ```\n\n  **寄生组合式继承和一般组合继承的差别在于SubType.prototype属性，寄生组合式继承SubType.prototype是SuperType.prototype，而组合式继承SubType.prototype是SuperType的实例**\n\n* **ES 6 中的“类”继承** ：通过extends关键字实现继承，extends 的本质是做了原型链连接，实现了方法的继承，属性的继承则通过在子类构造函数里调用super()实现\n\n  ```javascript\n  class SubType{\n    constructor(name){\n      this.name = name\n    }\n  }\n  class SuperType extends SubType{ //extends 实现方法继承\n    constructor(name){\n      super(name) //属性继承\n    }\n  }\n  ```\n\n  **ES 6 中的继承只是个语法糖，本质上是ES 5中的组合寄生式继承**\n\n  ​\n\n","tags":["个人总结"],"categories":["JavaScript"]},{"title":"ECMAScript中的数据类型","url":"/2018-04-03-ECMAScript中的数据类型/","content":"\nECMAScript里一共是由以下几种类型的：Undefined、Null、Boolean、String、Number、Object、Symbol，其中**Symbol是ES6中新加入的类型。我们暂时先把Symbol放在一边，只讨论其他六种类型，亦即ES5中的六种数据类型**。\n\n\n\n## Part 1— {简单数据类型，复杂数据类型}\n\n<img src=\"img-1.png\">  \n**上图来自ECMAScript Specification 5th Edition**\n\n从规范里，我们可以看到在ES5中有且只有六种数据类型，只要是ES5中的数据，不管有多么清奇的叫法，追根溯源，必然是这六种数据类型中的一种。\n\n我们可以将ES5中的六种数据类型做个简单的分类， **【简单数据类型**，**复杂数据类型**】 。这种分类方法是Zakas在红宝书里提到的。简单数据类型包括：**Undefined，Null，Boolean，String，Number **，复杂数据类型相对比较孤单，只有**Object**一种。之所以 **Undefined，Null，Boolean，String，Number** 会被划入简单数据类型，是因为这五种类型的可取值有限：\n\n- Undefined类型只有一个值：undefined\n- Null类型只有一个值：null\n- Boolean类型有两个值：true、false\n- String类型的值：字符串\n- Number类型的值：数字\n\n比之于上面五种类型，Object取值就很复杂了，Object本质上是由一组无序的键值对组成的。\n\n那我们如何去检测一个数据是什么类型的呢？ES中有一个**typeof**运算符可以用来检测数据类型，使用typeof运算符的确可以检测大部分数据类型，但是需要注意：\n\n- typeof  null  返回的是object\n- typeof function 返回的是function，而不是object\n\n那为什么typeof null 返回值是object呢？我们先来看一下MDN上的解释：<u>*在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了\"object\"*</u> 。现在大家普遍认同，typeof null 返回object 是一个历史错误，为了保持兼容性而维持到现在，ECMAScript提出过一个修复，但是被残忍拒绝了。\n\n那为什么typeof function 不返回object呢？这里我们还是来看一下贺老的回答，[js里function也算一种基本类型？](https://www.zhihu.com/question/24804474) <u>看完回答是不是又要惊叹贺老的深厚技术底蕴了？</u>总结下贺老的回答，核心就是**在spec里，typeof只是一个运算符，其返回值并不能作为JS类型依据**\n\n\n\n## Part 2— {基本数据类型，引用数据类型}\n\n{基本数据类型，引用数据类型}和{简单数据类型，复杂数据类型}之间有什么异同呢？它们只是按照不同标准对ES5中6种数据类型的不同分类罢了，没有实质上的区别。<u>{基本数据类型，引用数据类型}是根据值访问、引用访问来对数据类型进行的分类，{简单数据类型，复杂数据类型}的分类标准更加随意，由数据类型取值复杂程度进行分类</u>。\n\n基本数据类型和引用数据类型又具体包含哪些呢？\n\n- 基本数据类型：Undefined、Null、Boolean、Number、String\n\n- 引用数据类型：除了上面的5中基本类型，剩下的就是引用类型。**统称为Object类型，细分的话有：Object类型、Array类型、Date类型、RegExp类型、Function类型等**，这个说法是我从[JavaScript 深入了解基本类型和引用类型的值](https://segmentfault.com/a/1190000006752076)借鉴来的，目前为止我没有在相对权威的资料中看到过。这个说法我个人认为是正确的，Object.prototype.toString.call()可以佐证。\n\n  <img src=\"img-2.png\">\n\n**在ES中，变量是没有类型的，只有值才有类型。对变量执行typeof操作，得到的并不是变量的类型，而是变量持有的值的类型。ES中变量可能持有两种类型的值：基本类型的值和引用类型的值。基本类型的值是按值访问的，引用类型的值是按引用访问的。**\n\n👆上面的这段话说的其实相当拗口，看完大多数人也就是云里雾里。还是看看在ES中存储机制。\n\n\n\n## Part3—{ES中的存储机制}\n\n**1.  堆与栈**\n\n内存空间可以分为栈空间和堆空间。\n栈空间：由操作系统自动分配释放，存放函数参数值、局部变量的值等。其操作方式类似于数据结构中的栈。\n堆空间：一般由程序员分配释放，需要考虑垃圾回收问题。\n\n**2. 引用类型和基本类型的存储**\n\n基本类型：在内存中占据固定大小，基本类型的值保存在栈空间中，按值访问。\n引用类型：引用类型值大小不固定，需要动态为其分配内存空间，所以引用类型的值是存储在堆内存中的。其地址是固定大小的，可以将其地址保存在栈空间中。\n\n<img src=\"img-3.png\">   图片来自[【前端进阶之路】内存基本知识](https://segmentfault.com/a/1190000006104910)，侵删\n\n**3.  访问引用类型变量**\n\n访问引用类型变量时，先从栈空间中读取地址，再根据地址找到堆空间中保存的具体的值。这是一个透明的过程。\n\n**4.  参数传递：值传递？引用传递？**\n\nES中所有的传递都是值传递。对于保存基本类型值的变量来说是没有任何异议的。**对于保存引用类型的值的变量来说，实质上保存的是引用类型值的地址，它们之间也采用值传递，传递的内容即引用类型值的地址。**\n\n**5.  变量复制**\n\n基本类型：会复制变量值，复制前后两个变量独立。\n引用类型：也会复制***变量值***，这个地方的变量值是指变量中实际存储的引用类型值的地址。复制前后两个变量将保存指向同一内存空间的地址，使用任一变量修改该地址指向的内容，将会同时影响通过两个变量访问到的引用类型实际值。\n\n## 参考资料\n\n- 【文章】[JavaScript 深入了解基本类型和引用类型的值](https://segmentfault.com/a/1190000006752076)\n- 【知乎】[js里function也算一种基本类型？](https://www.zhihu.com/question/24804474)\n- 【文章】[前端进阶之路-内存基本知识](https://segmentfault.com/a/1190000006104910)\n\n\n","tags":["个人总结"],"categories":["JavaScript"]},{"title":"回调的三生三世","url":"/2018-03-27-回调的三生三世/","content":"\n暂时没有思路，不知道怎么去写","tags":["个人总结"],"categories":["JavaScript"]},{"title":"CSS-spec-visual-formatting-model","url":"/2018-03-15-CSS-spec-visual-formatting-model/","content":"\n> 不论是以理论为本的《CSS权威指南》还是主打工程经验的《CSS世界》，在一些概念上总给人一种含糊不清的感觉。不得已只能看[css-spec](https://www.w3.org/TR/CSS2/visuren.html)，也只有spec讲的透彻。不管是《权威指南》还是《CSS世界》都经过了别人的理解消化，和spec本身还是有一定的出入。一千个人眼里有一千个哈姆雷特。\n\n**1. Block-level elements and block boxes（块级元素及其相关的盒子）**\n\n* Block-level box（块级框）\n\n  块级框是由块级元素生成的基本框，块级框是在块级格式化上下文( Block formatting context )中的。\n\n* Block container（块容器）\n\n  块容器包含:  { 除table boxes 和替换元素之外的块级框,  非替换inline blocks,  非替换table cells}。\n\n  **一个块容器内要么只包含块级框( block-level boxes ) 要么只包含内联级框( inline-level boxes )**\n\n* Block boxes（块框）\n\n  那些是块容器的块级框又被称为块框，也就是**除table boxes和替换元素之外的块级框又叫块框**\n\n<img src=\"img-1.png\" width=\"700px\">   图片来自[stack overflow](https://stackoverflow.com/questions/30883857/css-spec-block-level-box-block-container-box-and-block-box) ，侵删 \n\n\n\n**2. Inline-level elements and inline boxes（内联元素及其相关的盒子）**\n\n* Inline-level box（内联级框）\n\n  内联级框由内联元素生成，在内联格式化上下文中( Inline formatting context )\n\n* Inline box（内联框）\n\n  内容物在内联格式化上下文中的内联级框。**display值为inline的非替换元素会生成内联框**\n\n* Atomic inline-level box （原子内联级框）\n\n  不是内联框的内联级框，这么说其实有点绕，换一种说法，内容物不再内联格式化上下文中的，比如替换inline-level元素、inline-block元素、inline-table元素生成的内联级框\n\n  <img src=\"img-2.png\" width=\"500px\">     图片来自[MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model) ，侵删 \n\n* Anonymous inline boxes （匿名内联框）\n\n  任何直接包含在块容器内部的文字都会生成匿名内联框。空白内容不会生成匿名块级框，空白内容受**white-space属性**控制\n\n**3. 盒子放置**\n\n在CSS2.1中，一个盒子能够放置在常规文档流中( Normal flow )，或者是“浮动流”( Floats )中，或者绝对定位流( Absolute positioning )中，绝对定位流包含了**绝对定位和固定定位**。浮动流和绝对定位流是我个人杜撰出来的名词🤡。\n\n> In CSS 2.1, a box may be laid out according to three positioning schemes:\n>\n> 1. Normal flow. In CSS 2.1, normal flow includes block formatting of block-level boxes, inline formatting of inline-level boxes, and relative positioning of block-level and inline-level boxes.\n> 2. Floats. In the float model, a box is first laid out according to the normal flow, then taken out of the flow and shifted to the left or right as far as possible. Content may flow along the side of a float.\n> 3. Absolute positioning. In the absolute positioning model, a box is removed from the normal flow entirely (it has no impact on later siblings) and assigned a position with respect to a containing block.\n\n**4. 格式化上下文（formatting context）**\n\n在常规文档流中的各种盒子是处在格式化上下文中的，块级盒子在块级格式化上下文( BFC )中，内联级盒子在内联格式化上下文( IFC )中。\n\n* 块级格式化上下文( BFC )\n  * 浮动元素、绝对定位元素、生成块容器且不生成块框的元素(inline-block元素、table-cell元素、table-captions元素)、生成块框且overflow属性不为visible的元素会**为其内容物生成新的BFC**\n  * 在同一个BFC中，相邻的垂直margin会塌陷( collapse ) ，[ **我在其他博文里也写过margin塌陷，如果和本文有冲突，以本文为准** ]\n* 内联格式化上下文( IFC )\n  * 行框：包含了构成一个文本行的所有内联/内联级/原子内联级盒子的矩形区域 ( The rectangular area that contains the boxes that form a line is called a line box )。行框的宽度是由包含块宽度和周围是否存在浮动元素决定的。\n\n  * 当行框中内联/内联级/原子内联级盒子A高度小于行框高度时，盒子A的对齐方式是由vertical-align属性决定的。\n\n  * 当一个行框无法容纳下多个内联/内联级/原子内联级盒子时，他们会被放在多个行框中，多个行框中内有分隔、没有重叠\n\n  * 当一个内联/内联级/原子内联级盒子 B 宽度超出了行框宽度时，盒子B会被拆成多个盒子，如果盒子B不能拆分(B中只有单个字符、word break 的特殊属性等)，会发生内容溢出。盒子B被拆分后，margin、border、padding不会有视觉变化\n\n    <img src=\"img-3.png\" width=\"400px\">     图片来自[CSS-spec](https://www.w3.org/TR/CSS2/visuren.html#block-boxes) ，侵删 \n\n    ​","tags":["阅读整理"],"categories":["CSS"]},{"title":"css权威指南-浮动和定位","url":"/2018-03-08-css权威指南-浮动和定位/","content":"\n《CSS权威指南》里第二个有价值的章节。\n\n这一章的内容比较碎，如果在文章里堆积知识点，不会有太大的价值，不论是对我还是对这篇博文的读者。我挑了几个比较有意思的点，整理了一下。\n\n**1. 包含块**\n\n不论是浮动元素还是定位元素，它们浮动和定位均是相对于包含框来进行浮动、定位的。**包含块——参考坐标系**\n\n**浮动元素**：浮动元素的包含块是其最近的块级祖先元素\n\n**根元素**：根元素的包含块( 初始包含块 )由用户代理建立，在大多数浏览器里，初始包含块是一个视窗大小的矩形\n\n**position : static/relative的非根元素**：包含块由最近的块级框、表单元格或者行内块祖先框的内容边界构成\n\n**position : absolute的非根元素**：包含块为最近的position值不是static的祖先元素。如果祖先元素是**块级元素**，包含块为**该元素的内边距边界**；如果祖先元素是**行内元素**，包含块为**该元素的内容边界**；如果没有祖先，包含块为初始包含块\n\n**position : fixed**：包含块是视窗\n\n**2. 浮动、定位对元素本身的影响**\n\n* 浮动\n  * 浮动元素会以某种方式从正常文档流中移除，但**仍旧影响布局**。浮动元素同时处于流内和流外\n  * 浮动元素**会生成一个块级框，不论元素本身是块级或是行内元素**\n  * 浮动元素周围的外边距不会合并 => float 不为none时会生成新的BFC，只有同一个BFC中的相邻margin才会合并\n\n* 绝对定位元素\n  * 绝对定位元素会从文档流中完全删除\n  * 相对于其包含块定位，其边界根据偏移属性放置\n  * 会为其后代元素建立一个包含块\n\n* 固定定位元素\n  * 固定定位元素会从文档流中去除\n  * 相对于视窗定位\n\n* 相对定位元素\n  * **只是从其正常的位置移走，原来所占的空间并不会因此消失**\n\n\n**3. 包裹性**\n\n当元素设置了浮动属性或者是进行了绝对定位、固定定位时，如果不显式设置元素宽度，元素会具有一定的包裹性，使其刚好能够容纳下当前内容。\n\n* float\n\n  当元素设置了浮动属性时，会有一些细微的变化。CSS权威指南上是这么表述的，`浮动元素会生成一个块级框，不论元素本身是块级还是行内元素`。不过我更加偏向于张鑫旭的表述，`撇开浮动的破坏性，浮动就是个带有方位的display:inline-block属性`。(详见[float深入研究1-张鑫旭](http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%B8%80/) 、 [float深入研究2-张鑫旭](http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%BA%8C/)) \n\n  按照**float是带有方位的display:inline-block属性**来理解，**由于display:inline-block会对元素产生包裹性**，从而就不难解释元素设置了浮动属性后会对其自身产生包裹性。\n\n* positon : absolute/fixed\n\n  对于相对定位元素和绝对定位元素，除了不显示设置width值之外，还须保证left/right中至少有一个为auto，否则其宽度将是`left` 到 `right` 之间的距离\n\n\n\n**4. 浮动为什么会导致父元素高度塌陷**\n\n首先需要了解高度是怎么产生的。这里引用张鑫旭的一段解释，`在目前的CSS世界里，所有的高度都是由两个CSS模型产生，一个是box盒状模型：height + padding + margin，另一个是line box模型，对应样式为line-height`  前者比较常见，后者对应文字等inline boxes元素。行内元素高度是怎么取得的呢？一个文本行是由若干个行内元素组成的。**一个文本行的高度是由其行框高度 决定的，而行框高度则是由该行中出现的行内框的最高点和最低点决定的，行内框又和line-height值相等**，从而 `文本行高度和该行中各个行内元素的line-height高度相关`\n\n要想解释浮动使得父元素高度塌陷，需要先了解下张鑫旭对**浮动的包裹性和破坏性**的定义[ 我个人是认同张鑫旭的解释的 ]。   `浮动的包裹性让元素变成类似于inline-box元素，浮动的破坏性破坏的也正是inline-box`。包裹性上文已经说过了，现在来看一下破坏性有什么影响。\n\n浮动元素所在文本行的高度是由其中的行内框高度所决定的。当浮动的破坏性破坏了浮动元素的inline-box，也就相当于破坏了其行内框，对于所在的文本行，其中将不包含任何行内框，那么该行高度应变为0。对于浮动元素的父元素，其可见高度应该由内容区+padding+border构成，内容区高度和浮动元素所在行高有关，由于浮动，浮动元素所在行行高将变为0。此时，当浮动元素高度大于其父元素的`padding + border` 就会出现高度塌陷。\n\n**5. clear到底做了什么**\n\n设置了浮动可能会导致父元素高度塌陷，这个时候需要清除塌陷，清除塌陷可以利用 `clear` 属性来完成。那`clear` 属性到底做了啥呢？\n\n在CSS1和CSS2中，clear会增加元素的上外边距，使之最后落在浮动元素的下面。\n\n在CSS2.1中引入了清除区域，清除区域是在元素上外边距之上增加的额外间隔，不允许任何浮动元素进入这个范围内，也就是说元素设置clear属性，其外边距并不会改变，之所以下移是清除区域造成的。我在chrome中进行了测试，验证了清除区域的存在。\n\n**6. 定位元素如何放置、大小**\n\n这块不知道怎么整理，直接看书可能是更好的选择。**《CSS权威指南》P327-P333**\n\n\n\n**7. 层叠上下文**\n\n具体参考博文[The-Stacking-Context](https://spades-s.github.io/2018-01-08-The-Stacking-Context/)\n\n  \n\n  \n\n\n\n","tags":["阅读整理"],"categories":["CSS"]},{"title":"css权威指南-视觉格式化","url":"/2018-03-05-css权威指南-视觉格式化/","content":"\n在《CSS权威指南》前七个章节里，视觉格式化是最有意思的一个章节，也是值得反复阅读的章节。\n\n{% asset_img img-1.png %}\n\n章节大的骨架如上。从格式化的对象上可以分为两个大类，块级元素和行内元素。块级元素有两方面的格式化，一个是水平格式化，另一个，垂直格式化。行内元素需要进行行内格式化，行内格式化同样可以根据格式化对象的不同分为行内替换元素格式化、行内非替换元素格式化。\n\n对于一部分前端从业者，更熟悉的应该是块级元素视觉格式化，相较于行内元素视觉格式化，块级元素视觉格式化更加简单。\n\n## 块级元素\n\n**1. 水平格式化**\n\n在块级元素水平格式化并且**仅在水平格式化**里有一个公式，掌握了这个公式基本可以解决80%的问题：\n\n`margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = width of ParaentElement`\n\n* 使用auto\n\n  在`width`  `padding`  `border`  `margin`  这四个属性里，能够将值设置为auto的只有 `width`  `margin-left`  `margin-right` \n\n  **如果三个值同时指定**， 在  **ltr**  语言中，用户代理会强制将`margin-right`置为auto\n\n  **只有一个值为auto**时，被设置为auto的属性将会自行确定所需的长度 ( 根据公式 ) \n\n  **有两个值为auto**时，如果是`margin-left` 和 `margin-right` 被设置为auto，该元素将会水平居中；如果是两个auto中包含`width`，被设置为auto的margin值将会等于0\n\n  **有三个值为auto**时，此时`margin-left` 、`margin-right` 都会等于0\n\n  总结：`margin-left`  `margin-right`  `width` 三个属性的优先级：`width` > (`margin-left` = `margin-right`)，优先级高的属性将会抢先占据父元素width中尚未被占用的宽度 \n\n* 负边距\n\n  一般的问题可以通过公式来解决\n\n* 百分数\n\n  `width`  `margin`  `padding`  的百分数值均以父元素宽度作为参考\n\n**2. 垂直格式化**\n\n块级元素垂直格式化是**不存在七个属性相加等于父元素宽度的公式的！！**\n\n* 使用auto\n\n  如果块级正常流元素高度设置为auto，并且只有块级子元素，其默认高度是**从最高块级子元素的外边框边界到最低块级子元素的外边框边界**。**当块级元素有内边距或者是边框时，其高度将会从最高子元素上外边距边界到最低子元素下外边距边界**。\n\n* 外边距合并\n\n  在外边距合并上，最合理的解释应该是：**同一个BFC中的相邻外边距会发生合并**\n\n## 行内元素\n\n{  `行框`  {  `行内框`   {  `内容区`  }  } }\n\n**行框**： 包含该行中出现的行内框的最高点和最低点的最小框。 \n\n**行内框**：对于非替换元素，元素行内框高度等于line-height；对于替换元素，元素框高度等于内容区高度。非替换元素的外边距不会对行内框的高度产社任何影响，会影响到行内框的宽度。\n\n**内容区**：对于非替换元素，内容区是各个字符的em框串在一起的框；对于替换元素，内容区是元素固有高度+可能有的内外边距和边框。\n\n总结：每一个行框内会包含若干行内框\n\n**1. 行内非替换元素**\n\n非替换元素的内容区高度由font-size值确定，行内框高度由line-height值确定。当line-height值小于font-size时，行间距会取得负值。行间距 = line-height - font-size。当行间距为负值时，元素行内框的顶端在内容区内部。\n\n**2. 行内替换元素**\n对于行内替换元素，内边距会在**具体内容外插入空间**。给替换元素设置负外边距会减少替换元素行内框的大小。\n\n默认情况下，行内替换元素位于基线上。\n\n**3. line-height**\n\n这里单独把line-height拿出来作为一个点。\n\n* 由于line-height会被子元素继承，在给line-height赋值时最好将其设置为原始数字值，将其设为缩放因子。其具体的line-height计算值 = 元素font-size * line-height缩放因子 \n* 另一个需要关注的点：如果给vertical-align设置百分数值，其计算值 = line-height计算值 * 百分数值\n\n","tags":["阅读整理"],"categories":["CSS"]},{"title":"The-Stacking-Context","url":"/2018-01-08-The-Stacking-Context/","content":"\nCSS，Cascading Style Sheet，层叠样式表，从字面上来看CSS最关键的三点，层叠、样式、表，这三个关键点里，`样式`说明了CSS的作用目标、功用，`表`说明了CSS的长相，而`层叠`表述的是CSS自身有何特点。CSS这东西不比人，并不能因为姓名和长相而让使用者记住它，只有`层叠`这个特质，能够让人从万千事物中分辨出它。\n\n层叠，意味着`可覆盖`，用户只能够看到最上层的东西，开发者必须将最终要的东西放在最上面，让用户能够一眼就看到。为了实现这个目标，开发者必须弄懂页面是按照何种方式、何种顺序绘制层叠上下文的。\n\n在学习层叠上下文绘制顺序之前，我们需要了解什么情况下会生成层叠上下文。能够产生层叠上下文的常见情况：\n\n```\nHTML文档的根元素；\nposition属性值为absolute或者relative并且z-index值不为auto的元素；\nposition属性值为fixed或者是sticky的元素(position:sticky在所有移动端浏览器上均生成层叠上下文，在老的pc浏览器上不会)；\nflex 容器里的元素，并且其z-index不为auto；\nopacity值小于1的元素；\ntransform、filter属性值不为none的元素；\n```\n\n>  以上是我觉得比较常见的几种情况，当然这也只是一部分，全部情况可以参看[The stacking context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)。\n\n现在我们可以去学习层叠上下文在页面绘制时是按照何种顺序进行绘制的了。**需要强调的是下面说的顺序只在一个层叠上下文中适用**\n\n**from BACK  to FRONT**\n\n```\n层叠上下文的根元素；\nz-index值为负数的定位元素(positioned elements)及其子元素；\n非定位元素(同为该种元素时按照HTML文档中的先后顺序)；\nz-index值为auto的定位元素及其子元素（同为该种元素时按照HTML文档中的先后顺序）；\nz-index值为正数的定位元素及其子元素；\n```\n\n\n\n> 又要当一次小偷了，[What No One Told You About Z-Index](https://philipwalton.com/articles/what-no-one-told-you-about-z-index/)这篇文章写的太好了，我不忍心去翻译，翻译出来的像狗啃过的（我还特地看了下左上角的intro，Philip Walton engineer @ Google，由衷感叹谷歌的工程师真牛逼）\n\n文章部分内容摘录如下：\n\n### Global Stacking Order\n\nWith a firm understanding of how/when new stacking contexts are formed as well as a grasp of the stacking order within a stacking context, figuring out where a particular element will appear in the global stacking order isn’t so bad.\n\nThe key to avoid getting tripped up is being able to spot when new stacking contexts are formed. If you’re setting a z-index of a billion on an element and it’s not moving forward in the stacking order, **take a look up its ancestor tree and see if any of its parents form stacking contexts. If they do, your z-index of a billion isn’t going to do you any good**.\n\n### Wrapping Up\n\nGetting back to the original problem, I’ve recreated the HTML structure adding comments within each tag indicating its place in the stacking order. This order is assuming the original CSS.\n\n> 这块如果没有前文的CSS代码，是很难读懂的，CSS代码如下\n>\n> .red, .green, .blue {\n>   position: absolute;\n> }\n> .red {\n>   background: red;\n>   z-index: 1;\n> }\n> .green {\n>   background: green;\n> }\n> .blue {\n>   background: blue;\n> }\n\n```html\n<div><!-- 1 -->\n  <span class=\"red\"><!-- 6 --></span>\n</div>\n<div><!-- 2 -->\n  <span class=\"green\"><!-- 4 --><span>\n</div>\n<div><!-- 3 -->\n  <span class=\"blue\"><!-- 5 --></span>\n</div>\n\n```\n\n> 这个地方为什么是先渲染了div ，然后才渲染其中的span呢？\n>\n> [spec](https://www.w3.org/TR/CSS2/zindex.html)中的两条规则应该就是最合理的解释（标号沿用了文档中的标号）：\n>\n> 4    *  For all its in-flow, non-positioned, block-level descendants in tree order: If the element is a block, list-item, or other block equivalent:\n> 1. background color of element.\n> 2. background image of element.\n> 3. border of element.\n>\n>  \n>\n> 7    * Otherwise: first for the element, then for all its in-flow, non-positioned, block-level descendants in tree order:\n> 1. If the element is a block-level replaced element, then: the replaced content, atomically.\n> 2. Otherwise, for each line box of that element:\n>\n> 我的理解：在一个层叠上下文中，首先绘制的是在文档流中的非定位块级后代元素，然后是line-box（这里还是有待进一步考证）\n\nWhen we add the opacity rule to the first `<div>`, the stacking order changes like so:\n\n> add opacity rule to the first div:\n>\n> div:first-child {\n>   opacity: .99;\n> }\n\n```html\n<div><!-- 1 -->\n  <span class=\"red\"><!-- 1.1 --></span>\n</div>\n<div><!-- 2 -->\n  <span class=\"green\"><!-- 4 --><span>\n</div>\n<div><!-- 3 -->\n  <span class=\"blue\"><!-- 5 --></span>\n</div>\n\n```\n\n`span.red` used to be `6` but it’s changed to `1.1`. I’ve used dot notation to show that a new stacking context was formed and `span.red` is now the first element within that new context.\n\nHopefully it’s now a little more clear why the red box moved behind the other boxes. The original example contained only two stacking contexts, the root one and the one formed on `span.red`. When we added opacity to the parent element of `span.red` we formed a third stacking context and, as a result, the z-index value on `span.red` only applied within that new context. Because the first `<div>` (the one we applied opacity to) and its sibling elements do not have position or z-index values set, their stacking order is determined by their source order in the HTML, which means the first `<div>`, and all the elements contained within its stacking context, are rendered behind the second and third `<div>` elements.\n\n> 上面摘录的片段，最主要是用以说明**z-index 是在positioned元素上起作用，z-index只影响该元素在父层叠上下文层级间的前后顺序**\n>\n>  **Importantly, the z-index values of its child stacking contexts only have meaning in this parent. From MDN**\n\n\n\n### conclusion\n\n1. opacity 小于0 形成的层叠上下文，最大的功用就是形成了层叠上下文，对层叠上下文中的层级并没有半点影响（个人感觉）\n2. 如果真的想对层叠上下文有个更加深入的了解，还是看[spec](https://www.w3.org/TR/CSS2/zindex.html)比较好，层叠上下文中各个元素、子层叠上下文的渲染顺序是什么样的，[spec](https://www.w3.org/TR/CSS2/zindex.html)解释的应该是最全的了。","tags":["个人总结"],"categories":["CSS"]},{"title":"bye，我的2017","url":"/2018-01-01-bye，我的2017/","content":"\n> 這篇文章起源於給一個朋友的信，信中內容盡是自己一年來的回憶，寫完整理了下，當做自己17年的文字記錄，我很少留存圖片記錄，能留下一些文字記錄也彌足珍貴了\n\n寫下這些文字的時候已經是2018年了，從一個新的節點往回看，總會覺得時間過得很快，確實啊，2017年過得有些匆忙，上半年忙著離開民族大學，下半年忙著些什麼也說不太清楚，總歸，瞎忙吧。\n\n17年，我的本科生活結束了，班裡的散伙飯吃的挺匆忙的，我的感覺是這樣的，那個時候大家都各自有很多事情，很難找到一個時間一塊吃頓飯。匆忙定了個時間，班裡租了個地方，飯是自己做的，種類挺豐富的，現在我能記住的只有那麼幾件事：胖子（ZSX）是大廚，做了好些吃的，印象中是受到了一致好評，但是具體我吃沒吃到胖子做的菜我記不清楚了，我只記得當時我只盯著我面前的那盤菜吃，其他的菜好像是沒下過筷子；米飯不好吃，放的水有點多了，煮的比較爛，我不太喜歡吃這種米飯；我竟然有燒烤天賦，我烤的串比朱老師烤的好吃很多，當然是吃過我烤的串兒的朋友告訴我的，我自己是不吃我烤的串兒的，我分辨不出熟沒熟（如果以後我真的開了串兒吧，來吃的朋友一定要當心），這也是我一直不會做菜的原因之一。那頓飯我吃的是沒什麼感覺的，不是我想象中的把酒惜別又或是一曲高歌頌別離，大家都還是以一個小圈子在玩，以宿舍為單位的那種，也可能是我沒放開，沒能融入進去。\n\n賢哥（MJX）是最早離校的，我記憶中是送他出了六號樓的大門，沒有擁抱一下也沒有說太多話，好像只有一句一路順風吧。賢哥給我留下的最大一筆財富就是他的飯卡了。我記得是兩位數以上的餘額。拿著賢哥的卡，呼朋引伴，真的是呼朋引伴，324和317都有，一塊在風味食堂吃了一頓，好像是香鍋，由於刷別人的卡的感覺實在太爽，刷卡的的時候情不自禁說了一句“刷別人卡的感覺真爽”，窗口大姐盯著我看了很久，用一種極其古怪的眼神，最後老夫（TH）受不了這種眼神（刷卡的時候老夫是站在我邊上的），解釋了下“用的室友的卡”，大姐才收回那古怪的眼神。\n\n自此，每有一個離校，我就會多收到一張飯卡，到我自己離校的時候，手裡已經有四五張卡了。\n\n{% asset_img bye-1.jpeg %}\n\n到了2017年下半年，總有一些奇怪的事情：體檢有一項指標不合格，校醫院給通知的時候，我總擔心自己是不是得了什麼絕症，複查結果出來前的那十來天時間里我特別忐忑，好在最終是一場虛驚。後面，好像是10月份這樣，手腕又出現了一個囊腫，不過沒什麼大影響。經歷了這幾個事，尤其是第一件，我發現我自己真的挺怕死的，生命也著實很寶貴。\n\n17年基本就是這樣了。\n\n18年了，新年快樂  ^_^\n\n","tags":["杂感"],"categories":["随笔"]},{"title":"清除浮动","url":"/2017-12-31-清除浮动/","content":"\n> 很久没有更新过博客了，看了下归档，最新的一篇是11月份写的，再往前就是只能追溯到8月份了，但是今天已经是17年的最后一天了，间隔太久了。除了更新间隔太久之外，博文的质量总体不高，大多只能算是“摘录”，内化的东西比较少。趁着这个机会整理了一下博客，把一些没有必要的都删掉了。往后博客还是得有个固定的更新时间，毕竟`output is input` ，写博文也是重要的一环。\n>\n> 也顺势对分类和标签做个规定吧，分类按照其本义，对博文进行分类，标签呢，就放两个吧，{个人总结+阅读摘录}，具体表述可能会变化，但是总体上是这两个意思。\n\n2017年里，写了两篇关于清除浮动的博文，一篇是经典文章[A new micro clearfix hack](http://nicolasgallagher.com/micro-clearfix-hack/)的翻译，另一篇写的非常水，我自己都看不明白写的是个啥（这两篇博文现在已经删了）。正好前段时间看了些关于清除浮动的资料，有了一点自己的看法，做一个总结。\n\n——————————————————————————————————————————————————\n\n首先我们需要明确的一点是，清除浮动到底清除的是什么？浮动效果由float属性产生，可以使元素脱离常规文档流，有可能会导致浮动元素父级元素对象盒子不能被撑开，形成高度塌陷。到这儿，我们应该清楚，所谓的清除浮动，就是消除由浮动造成的高度塌陷问题。\n\n{% asset_img clearfix-1.png %}\n\n上图所展示的就是一个典型的浮动塌陷，左半部分是显示效果，右半部分是代码。图中代码想实现的效果如下：\n\n{% asset_img clearfix-2.png %}\n\n设置了背景的outer容器应该包含inner容器。\n\n在出现浮动塌陷的时候，就需要我们去做一些hack，让想要的效果显示出来。怎么去做hack呢？按照原理来分，可以分为两类，clear:both 和 生成BFC。 \n\n* clear:both\n\n首先来看一下clear:both，这可能是最古老的清除浮动的方式了（具体是不是最古老还有待考证）。使用clear:both 的常规操作：\n在浮动元素下，加一个div，将其CSS属性设置为：`clear:both`\n\n```html\n<head>\n    <style>\n        .outer {\n            padding: 20px;\n            width: 100%;\n            background: url(./b.jpg)\n        }\n        .inner {\n            float: left;\n            width: 50%;\n            height: 200px;\n            border: 1px solid red;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"outer\">\n        <div class=\"inner\"> inner</div>\n        <div style=\"clear:both\"></div>\n    </div>\n</body>\n```\n\n在添加完`clear:both`这个div之后，刷新一下，发现塌陷问题真的不见了。\n\n但是这是什么原理呢？为了更容易观察，将`clear:both`这个div背景设为紫色，设置其高度为20px，效果如下：\n\n{% asset_img clearfix-3.png %}\n\n**如果将`clear:both`这个属性去掉，会出现什么样的效果呢?**\n\n利用devtools取消clear属性，发现`clear:both`div 最上面的边界是和`float`div最上面的边界等高的。因为float-div脱离了常规文档流，但并不会影响常规文档流的布局。\n\n{% asset_img clearfix-5.png %}\n\n而`clear:both`起到的作用就是，将`clear:both`div强行放到`float`div之后。我的理解，在float元素所在区域其实是不能存在常规文档流布局，那个区域是个真空区域。\n\n> The clear CSS property specifies whether an element can be next to floating elements that precede it or must be moved down below them.  **From MDN**\n\n\n\n* BFC\n\n走过了远古时期，人类文明终于得到了进一步的发展。\n\n使用BFC的方式消除浮动塌陷，于我而言是一个比`clear:both`更加高级的方式，它不会影响HTML布局，不需要空标签。\n\n能够使用BFC的方式来清除浮动塌陷，原因在于：BFC是一个相对独立的区域，一个BFC会包含其中的所有子元素，无论浮动与否。\n\n>  in a [block formatting context](https://www.w3.org/TR/css-display-3/#block-formatting-context), floated boxes affect the layout of surrounding boxes. But their effects do not escape their [formatting context](https://www.w3.org/TR/css-display-3/#formatting-context): the box establishing their [formatting context](https://www.w3.org/TR/css-display-3/#formatting-context) grows to fully contain them, and floats from outside that box are not allowed to protrude into and affect the contents inside the box.                **From W3C-Spec**\n\n可以通过设置一些特殊的属性生成BFC：\n\n1. the root element \n2. float the element\n3. ensure the computed value of `overflow` is not `visible`\n4. set `display` to `inline-block, inline-table, table-cell or table-caption`\n5. set `position` to something other than `static or relative`\n\n\n\n* modern solution\n\n社会在发展，人类在进步，解决浮动塌陷也有了现代化的方法，这个方法即[A new micro clearfix hack](http://nicolasgallagher.com/micro-clearfix-hack/)提及的方法：\n\n```css\n.clearfix:afer{\n  content:'';\n  display: block;\n  clear: both;\n}\n```\n\n之所以会出现这个方法，是由于上述两种方法均存在缺陷，`clear`方法需要额外的标签，`BFC`方法由于需要设置`overflow`之类的属性，会对显示效果产生一定影响。\n\n但是这样还有可能会出现问题，`margin塌陷`，为了防止margin塌陷，可以将其改进为：\n\n```css\n.clearfix:before,\n.clearfix:after {\n  content: ' ';\n  display: table;\n}\n.clearfix:after {\n  clear: both;\n}\n```\n\n这个改进核心在于将`display`属性改为`table`，生成新的BFC，至于before伪元素，我觉得是可有可无的。\n\n\n\n> 在总结过程中，发现了一篇博文，[Understanding the Humble Clearfix](https://www.fuseinteractive.ca/blog/understanding-humble-clearfix)，我觉得是我看过的最好的讲清楚浮动的博文了，这篇博文也参考了[Understanding the Humble Clearfix](https://www.fuseinteractive.ca/blog/understanding-humble-clearfix)\n\n\n\n","tags":["个人总结"],"categories":["CSS"]},{"title":"ghost in vertical-align","url":"/2017-11-24-ghost-in-vertical-align/","content":"Thanks to [CSS深入理解vertical-align和line-height的基友关系](http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/)、 [Deep dive CSS: font metrics, line-height and vertical-align](https://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align)\n\n在布局的时候常常会发现，这个地方怎么多出来一块，理论上应该没有啊，这个“灵异事件”是怎么产生的？\b有一种“ghost”是隐藏在vertical-align下的，\b\b\b我们来一步一步抓住它。\b\n\n首先看下\b存在“ghost”是啥样子  \n{% asset_img ghost1.png [title] %}  \n\b\n实现\b的代码上面布局的代码:\n```html\n<head>\n    <meta charset=\"utf-8\">\n    <title>test</title>\n    <style>\n        * {\n            margin-top: 0;\n            box-sizing: border-box;\n        }\n        \n        div {\n            margin-top: 50px;\n            background: #bebece;\n        }\n        \n        img {\n            height: 200px;\n        }\n    </style>\n</head>\n<body>\n    <div>\n        <img src=\"./anywhere.jpg\" alt=\"\">\n    </div>\n</body>\n```\n代码结构非常近\b简单，\b一个有背景色的div和一张图片，按照常规的逻辑div的高度应该和img的高度一致，div里面只有img，计算高度时只有img的高度，但是奇怪的是，div的高度却要比img高出一些(\b见上图红框)\n\n为什么会出现这种\b\b奇怪的东西呢？张鑫旭\b\b用了一个\b自定义的概念解释了这个现象，“幽灵空白”节点，一个块容器中藏着一个幽灵空白节点，看不见摸不着，但的确存在！\n\n确实像张鑫旭说的那样，在一个块级容器中存在一个“无色无味不可触摸”的幽灵空白节点：\n{% asset_img ghost2.png %}\n上面的截图中，img下面都具有相同的空隙，但是不同的是`在img边上是否存在文字`。\n上面那个图是由如下的代码实现的：\n```html\n<head >\n    <meta charset=\"utf-8\">\n    <title>test</title>\n    <style>\n        * {\n            margin-top: 0;\n            box-sizing: border-box;\n        }\n        \n        div {\n            margin-top: 50px;\n            background: #bebece;\n        }\n        \n        img {\n            height: 200px;\n        }\n    </style>\n</head>\n<body>\n<div>\n    <img src=\"./anywhere.jpg\" alt=\"\">\n</div>\n<div>\n    <img src=\"./anywhere.jpg\" alt=\"\">\n    <span>spades</span>\n</div>\n</body>\n```\n从代码上加以分析，两个div唯一的不同点：是否具有span。div内部加上span之后img表现出的效果竟然和没有span时一致，那么对于第二个div来说，img下面的那个空隙是由span撑开的吗？给span加个背景看看吧\n{% asset_img ghost3.png %}\n从截图上直观地说，span确实是造成img下面有空隙的元凶。既然span是元凶，如果它的高度为0，从逻辑上来讲img下面的空隙就会消失。\n将span的font-size设为0：\n{% asset_img ghost4.png %}\n将span的font-size设置为0之后，span的确是消失了，但是img下面还是存在空隙。如果div里面真的有一个幽灵元素，并且img下的空隙的确是由那个幽灵空白元素造成的，那只给span设置font-size是不是不太够，也需要给那个幽灵元素设置下font-size\n在div上设置font-size：\n{% asset_img ghost5.png %}\n将divfont-size设置为0之后，img下的空隙消失了，在第一个div上设置font-size，img下的空隙同样消失。\n到此我们可以知道，一个块级元素里的确存在一个幽灵空白节点。w3c spec上是这么说的：\n``` text\nOn a block container element whose content is composed of inline-level elements, 'line-height' specifies the minimal height of line  \nboxes within the element. The minimum height consists of a minimum height above the baseline and a minimum depth below it, exactly as \nif each line box starts with a zero-width inline box with the element's font and line height properties. We call that imaginary box a\n\"strut.\"\n```\nw3c spec这段话的意思是说，对于一个内部只有内联元素的块级元素，它的最小高度里包含了minimum height，这个minimum height在baseline上下各有一个，就像是在这个块级容器中有一个宽度为0的元素一样。\n\n对于vartical-align，默认的值是baseline：align the baseline of the box with the baseline of parent box. If the box does not have a baseline, align the bottom with the parent's baseline.\nvertical-align 还有其他几个值：\n—— middle: align the vertical midpoint of the box with the baseline of the parent box plus half the x-height of the parent.\n—— sub: lower the baseline of the box to the proper position for subscripts of the parent's box.(This value has no effect on the font size of the element's text)\n—— super: raise the baseline of the box to the proper position for superscripts of the parent's box.(This value has no effect on the font size of the element's text)\n—— text-top: align the top of the box with the top of the parent's content area.\n—— text-bottom: align the bottom of the box with the bottom of the parent's content area.\n—— percentage\n—— length\n**The vertical-align property affects the vertical positioning inside a line box of the boxes generated by an inline-level element. The values only have meaning with respect to a parent inline element, or to the strut of a parent block container element**\n\n**for inline non-replaced elements, the box used for alignment is the box whose height is the \"line-height\". For other elements, the box used for alignment is the margin box**\n张鑫旭在他的文章里也提到了类似的表述，“css2 可视化格式文档模型中的一段话：The baseline of an 'inline-block' is the baseline of its last line box , unless it has either no in-flow line boxes or if its overflow property has a computed value other than visible, in which case the baseline is the bottom margin edge.” 在这里顺便借用下张鑫旭对这段话的翻译：“一个inline-block元素，如果里面没有inline内联元素，或者overflow不是visible，那么该元素的基线就是其margin底边边缘；否则，基线就是元素里面最后一行内联元素的基线”\n\n除了上面的值之外，vertical-align还可以去top和bottom：\n—— top: align the top of the aligned subtree with the top of the line box.\n—— bottom: align the bottom of the aligned subtree with the bottom of the line box.\n\n回到最初的话题，为什么img下会有空隙呢？原因在于，img 和 幽灵空白节点 的 vertical-align默认值均为baseline，对于img其baseline是margin底边缘，幽灵空白节点的baseline并不是margin底边缘（如下图中的span中文字节点的baseline，span的baseline并不是margin底边缘），所以会出现空隙\n{% asset_img ghost6.png %}\n\n\n\n\n\n\n\n\n\n","tags":["个人总结"],"categories":["CSS"]},{"title":"readlist","url":"/2017-08-29-readlist/","content":"\n[浅阅读]\n\n* [前端性能优化 - 资源预加载](http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/)\n\n* [Node.js 垃圾回收](https://eggggger.xyz/2016/10/22/node-gc/)\n\n* [JavaScript核心概念归纳整理](https://mp.weixin.qq.com/s?__biz=MzI2MTY0NTEyMA==&mid=2247483948&idx=1&sn=0e93dbb8dc3d9c9a439461bbdbc92b37&chksm=ea567403dd21fd156325f9845b0292b812394654bed9ac41dd05a266710504df3445eb8a21b3&mpshare=1&scene=1&srcid=0710k6oGplOMxqvgJRR0L0UG&key=3d8efa8bcd6863c30214801bcb5e016ca5b432ff2a34b0d1cb024ac870b8a7b84c113ca5f2bd479a6d2726075b227e6c57c28e0cb9680fdcdde32bf28e987823df919d0620532c81f46181a93ad9444e&ascene=0&uin=MjA1ODA2MzcxNw%3D%3D&devicetype=iMac+MacBookPro13%2C2+OSX+OSX+10.12.4+build)\n\n* [简单明了区分escape、encodeURI和encodeURIComponent](http://www.cnblogs.com/season-huang/p/3439277.html)\n\n* [详解JavaScript模块化开发](https://segmentfault.com/a/1190000000733959)\n\n  [写了十年JS却不知道模块化为何物？](https://blog.wilddog.com/?p=587)\n\n  [深入浅出ES6（十六）：模块 Modules](http://www.infoq.com/cn/articles/es6-in-depth-modules)\n\n* [ES6的工厂函数](https://zhuanlan.zhihu.com/p/28496170?group_id=881572384912609281)\n\n* [理解Service Worker](https://zhuanlan.zhihu.com/p/28461857)\n\n* [什么是访问器属性](https://www.zhihu.com/question/40648241)\n\n* [深入理解JavaScript中的属性和特性](http://www.58maisui.com/2016/11/03/842/)\n\n* [使用Flexible实现手淘H5页面的终端适配](https://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html)\n\n* [再聊移动端页面的适配](https://www.w3cplus.com/css/vw-for-layout.html)\n\n*  [HTML meta标签总结与属性使用介绍](https://segmentfault.com/a/1190000004279791)\n\n*   [AMD, CMD, CommonJS和UMD](https://segmentfault.com/a/1190000004873947)\n\n    ​\n\n\n[深阅读]\n\n* [css模块化及CSS Modules使用详解](http://blog.csdn.net/xiangzhihong8/article/details/53195926)\n\n*  [SCSS 一站式入门](https://github.com/FrankFang/githublog/blob/master/%E6%8A%80%E6%9C%AF/SCSS%20%E4%B8%80%E7%AB%99%E5%BC%8F%E5%85%A5%E9%97%A8.md)\n\n*  [浏览器~加载，解析，渲染](http://www.jianshu.com/p/e141d1543143)\n\n*  [What exactly is Hot Module Replacement in Webpack?)](https://stackoverflow.com/questions/24581873/what-exactly-is-hot-module-replacement-in-webpack)\n\n*  [ HTTP 缓存机制详解](https://mp.weixin.qq.com/s/8UXEMQBkV9hHwtu9R7mV5w)\n\n*  [module.exports vs. export default in Node.js and ES6](https://stackoverflow.com/questions/40294870/module-exports-vs-export-default-in-node-js-and-es6)\n\n*  [详解setTimeout与setInterval](http://danielwan.me/2017/04/detailed-in-settimeout-and-setinterval.html)\n\n*  [Rem布局的原理解析](https://zhuanlan.zhihu.com/p/30413803?hmsr=funteas.com&utm_medium=funteas.com&utm_source=funteas.com)\n\n*  [How JavaScript works: Event loop and the rise of Async programming + 5 ways to better coding with async/await](https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5)\n\n*  [前端精选文摘：BFC 神奇背后的原理](http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html)\n\n*  ​\n\n   ​\n\n\n","tags":["个人总结"],"categories":["readlist"]},{"title":"inline-block元素之间存在间隙、上下不对齐","url":"/2017-08-13-inline-block元素之间存在间隙、上下不对齐/","content":"\n- inline-block元素之间存在间隙\n\n  ```html\n  code-1\n  <div>\n    <span>First element</span>\n    <span>Second element</span>\n  </div>\n  ```\n\n  一般会如code-1编写内联元素，可是在浏览器中观测会发现这两个内联元素之间有几个像素的间隔，这为啥(一脸懵逼状)，这写得也没毛病啊(是吧，老铁？)\n\n  毛病还是有的。**换行符**。这也是这几个像素出现的祸因。\n\n  ```html\n  code-2\n  <div>\n    <span>First element</span><span>Second element</span>\n  </div>\n  ```\n\n  像code-2样编写内联元素，间隙就会消失。但是这也太丑了啊，如果不小心做个对齐，那不就没效果了。\n\n  换行符始终也是字符，也会受到font-size的影响，可以采用如下方法：overwrite  *font-size属性*  解决：\n\n  ```html\n  code-3\n  <style>\n    div{\n      font-size: 0px;\n    }\n    span{\n      font-size: 14px;\n    }\n  </style>\n  <div>\n    <span>First element</span>\n    <span>Second element</span>\n  </div>\n  ```\n\n- Inline-block 元素上下不能对齐\n\n  ```Html\n  code-4\n  <style>\n    \tdiv{\n    \t  font-size: 0px;\n    \t}\n  \tspan{\n        display: inline-block;\n        height: 1.5rem;\n        width: 50%;\n        font-size: 14px;\n  \t}\n    \t.second-element{\n        overflow:auto;\n    \t}\n  </style>\n  <div>\n    <span class=\"first-element\">First element</span>\n    <span class=\"second-element\">Second element</span>\n  </div>\n  ```\n\n  将code-4代码放入浏览器中观察，会发现first-element 和second-element上下不对齐，原因在于**基线不对齐**：``overflow:hidden`` ，这个属性会改变inline-block元素基线位置，导致上下不对齐\n\n  **解决方法**：同时设置两个元素垂直对齐方式``vertical-align:top`` 或者给两个元素同时添加``overflow``属性","tags":["个人总结"],"categories":["CSS"]},{"title":"rollerCoaster遇到的问题整理","url":"/2017-08-13-rollerCoaster遇到的问题整理/","content":"\n“好久没写过博客了，之前的博客也很随意，很多都是一些摘录，总体来说价值量不大。还是得像六哥学习，每周写一两个有价值的。”\n\n这段时间都在做`rollerCoaster`，现在基本上的功能都实现了，做这个项目最初的目的是长长工程经验，从16年下半年开始学习前端，就没有从头到尾地完成一个项目，rollerCoaster刚好给了我这个机会。这个项目的技术架构是我搭的，thinkjs+light7+vue，当时觉得这个架构挺不错的(现在看看，一个词，shit)，虽然这个架构有点屎，但是还是得分析一下：项目要求是webapp，为了便于前端布局，引入了light7，一个ui框架；vue做数据的动态绑定，vue用的非常浅，只是用来进行数据的动态绑定，整个项目都没有写组件，这应该是工程里的非常大的缺陷；thinkjs：基于nodejs的MVC框架，用thinkjs开发起来相当方便，对M和C的封装非常好。\n\n开发完，整体上看，项目的体验比较差，引入的资源太多，加载起来很慢，合理的方式应该是写组件，webpack打包，按需加载，提高用户体验。vue组件开发和webpack也是未来一个月，我学习方向。\n\n开发过程中遇到了不少的问题，对开发过程中的问题做一个整理：\n\n1. 如何更加优雅的处理文本溢出\n\n   ```css\n   //单行文本\n   {\n     overflow: hidden;\n     text-verflow: ellipsis;\n     white-space: nowrap;\n   }\n\n   //多行文本\n   {\n     display: -webkit-box;\n     overflow: hidden;\n     -webkit-line-clamp: 2;  //显示的行数\n     -webkit-box-orient: vertical;\n     text-overflow: ellipisis;\n   }\n   ```\n\n2. overflow : auto在ios上很卡顿\n\n   解决方法：`-webkit-overflow-scrolling: touch` ，这句会启动硬件加速，以达到流畅效果。\n\n   在WebKit 108400版本左右才支持，所以iOS Safari应该是需要5.0。Android则是在4.0以上支持。\n\n3. 在软键盘上显示`搜索`按钮\n\n   一般来说，在input标签上指定`type=\"search\"`即可在软键盘上显示搜索按钮，但是ios是个大BUG，在ios8及其以上版本中，需要在input外层包裹一个`含有action属性的formbba标签`\n\n4. 关于z-index\n\n   z-index只会在仅能在定位元素上生效\n\n5. <input type=\"file\" id=\"input\">多次上传的问题\n\n   对input做change监听可以判断是否上传了文件，但是在不刷新的情况下，再次上传是不会触发`change`的，为了实现reloa这个特性，需要在onchange这个监听函数中，将inpu 的value设置为空，document.getElementById(id).value = null\n\n6. 如何处理：Safari: [“cand 't create duplicate variable that shadows a global property”]\n\n   问题出现场景：\n\n   ```javascript\n   <div class=\"test\"></div>\n   let class = 'test'\n   ```\n\n   问题出现原因：变量名和id值或者class值相同，处理方法：将let换为var即可\n\n   “This is apparently a problem Safari has with declaring a let/const variable that shares the same name as a selected id attribute. I had some variables declared with const as you did and got the same error. Changed to let and still got it. Changed to var and it worked.\n\n\n\n   ​","tags":["个人总结"],"categories":["工程"]},{"title":"mysql修改root密码","url":"/2017-06-06-mysql修改root密码/","content":"\n一直没有从零开始倒腾过mysql，用的都是别人配置好的东西，安装、配置、修改root密码这些都没做过，就试了一下，坑比较多，需要填\n\n操作系统：macOS 10.12.4\n\nMysql：MySQL Community Server 5.7.18\n\nfirst：下载安装包，[mysql官网](https://dev.mysql.com/downloads/mysql/)下载\n\nsecond：安装，首次安装到最后会提示root的初始密码，这个密码记不记不太重要\n\nthird：修改root密码\n\n\t    1. sudo mysqld_safe --skip-grant-tables，进入安全模式\n\t    2. mysql -u root -p ，输入任意密码登录root\n\t    3. UPDATE mysql.user SET authentication_string=PASSWORD(‘123456’) where User=’root’; //将root用户密码改成 123456\n\t    4. flush privileges;  刷新权限，使配置生效\n\t    5. 输入mysql -u root -p命令，接着输入刚刚设置的密码，如果可以登录说明修改成功，则不需要进行下一步\n\t    6. 如果在第5步中出现your password has expired. to log in you must change it using a client that supports expired passwords错误，说明密码过期需要将密码过期字段设置为‘N’\n\t    7. use mysql \n\t    8. select * from mysql.user where user='root' \\G\n\t    9. update user set password_expired='N' where user='root';\n\t    10. flush privileges;  刷新权限，使配置生效\n\t    最后退出mysql，重新mysql\n\n\n\n\n\n折腾完mac上的mysql之后，又倒腾了一下centos server上的mysql\n\n操作系统：CentOs 7.3\n\n[Mysql: 7.5.6](https://dev.mysql.com/downloads/file/?id=469881)\n\n下载的是二进制包，直接解压缩即可\n\nfirst：创建mysql用户账号，`useradd -s /sbin/nologin -M mysql`\n\nsecond：修改配置文件，配置文件一般放在`/etc下，/etc/my.cnf`\n\n```shell\n[client]\nport = 3306\nsocket = /path-to-mysql/mysql.sock\ndefault-character-set = utf8\n[mysqld]\nskip-name-resolve\nuser = mysql\nbasedir = /path-to-mysql\ndatadir = /path-to-mysql/data\nport = 3306\nserver_id = 10\nsocket = /path-to-mysql/mysql.sock\npid-file = /path-to-mysql/mysql.pid\nlog-error = /path-to-mysql/data/mysql.err\nlog-bin = /path-to-mysql/data/mysql-bin\ncharacter-set-server = utf8\n```\n\n third：初始化数据库\n\n```\nchown -R mysql.mysql /data/mysq56\n\n\n/path-to-mysql/bin/mysql_install_db --defaults-file=/etc/my.cnf --user=mysql --basedir=/data/mysql56 --datadir=/data/mysql56/data\n\n```\n\nforth：修改密码，参考mac部分\n\nfifth：配置远程连接\n\n```\nGRANT ALL PRIVILEGES ON *.* TO username@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;\nFLUSH   PRIVILEGES;\n```\n\n至此，完美结束！\n\n\n\n\n\n如果不可以进行远程连接，可以尝试一下解决方案：\n\n查看mysql置文件\n\nvi /etc/my.cnf\n\n特别要留意其中的两项：bind_address和skip_networking,bind_address一定不能为127.0.0.1，否则只能在本地连接，skip_networking一定不能出现，否则只接受unix socket而不能提供tcp socket服务，建议将bind_address和skip_networking直接都注释掉。","tags":["个人总结"],"categories":["运维"]},{"title":"在网页中确定鼠标、元素的位置","url":"/2017-04-26-在网页中确定鼠标、元素的位置/","content":"\n在需要获取鼠标相对于元素的位置的时候，首先必须确定鼠标位置、元素位置，如此才能进行计算。鼠标位置、元素位置有多种获取方式，获取的值也各不相同，有的是相对于视口的，有的是相对于文档的....在没有滚动条的时候计算会很简单，相对于文档和相对于视口取得的值相同，一旦有了滚动条就会变得麻烦起来。\n\n\n\n### 获取鼠标位置\n\n* pageX、pageY\n\n  鼠标事件的只读属性(MouseEvent.pageX ，MouseEvent.pageY)pageX和pageY返回的是相对于整个文档的坐标，以像素为单位。\n\n  This property takes into account any vertical(pageX) , horizontal(pageY)scrolling of the page. ——from  MDN \n\n  这两个属性会把滚动也计算进去。但是这两个属性只会把body的滚动计算进去，如果是body内部元素的滚动需要在pageX、pageY上叠加上滚动的值。\n\n  其实这是一个有意思的事情。\n\n* clientX、clientY\n\n  鼠标事件的只读属性clientX和clientY返回的是相对于浏览器内容区域的X、Y坐标，不包含滚动的值\n\n   clicking in the top-left corner of the client area will always result in a mouse event with a `clientX` value of 0, regardless of whether the page is scrolled . ——from MDN \n\n* screenX、screenY\n\n  鼠标事件的只读属性screenX和screenY返回的是鼠标相对于屏幕的距离。\n\n* offsetX、offsetY\n\n  和pageX、pageY类似，只有IE支持\n\n  ​\n\n### 获取DOM元素位置和尺寸大小\n\n以下内容都是DOM元素的属性\n\n* offsetWidth 和 offsetHeight：元素宽度，包括border和padding\n\n* clientWidth 和 clientHeight：元素宽度，包括padding，不包含滚动条，margin，border。如果没有CSS属性或者是inline layout box其值将会是0\n\n*  scrollWidth和scrollHeight：元素的内容区域加上内边距加上溢出尺寸，当内容正好和内容区域匹配没有溢出时，这些属性与clientWidth和clientHeight相等\n\n* offsetLeft 和 offsetTop：和已定位父容器左上角的距离。\n\n  注意：对于块级元素来讲，offsetWidth、offsetHeight、offsetLeft、offsetTop描述的是一个元素border的宽度高度以及相对于offsetParent的距离\n\n  However, for inline-level elements (such as **span**) that can wrap from one line to the next, `offsetTop`and `offsetLeft` describe the positions of the *first* border box (use [`Element.getClientRects()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getClientRects) to get its width and height), while `offsetWidth` and `offsetHeight` describe the dimensions of the *bounding*border box (use [`Element.getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect) to get its position). Therefore, a box with the left, top, width and height of `offsetLeft, offsetTop, offsetWidth` and `offsetHeight` will not be a bounding box for a span with wrapped text.\n\n  因为不知道怎么翻译，就把这段话粘贴过来了\n\n* clientTop和clientLeft返回内边距的边缘和边框的外边缘之间的水平和垂直距离，也就是左，上边框宽度\n\n* scrollLeft和scrollTop是指元素滚动条位置\n\n","tags":["个人总结"],"categories":["JavaScript"]},{"title":"三栏式布局","url":"/2017-04-20-三栏式布局/","content":"\n“总结是一个好习惯”——孙悟空\n\nThanks to[三栏布局的n种实现](https://segmentfault.com/a/1190000005721963)\n\n### 实现三栏式布局的几种方案\n\n**方案一：绝对定位**\n\n绝对定位的元素将会脱离文档流，利用绝对定位将左右两栏抽离文档流，中间栏用margin值撑开可以容纳左右栏的距离。\n\n**方案二：浮动**\n\n左栏左浮动，右栏右浮动，中间栏用margin值撑开可以容纳左右栏的距离。**浮动框不在文档的普通流中，对于文档流中的普通块框，浮动框可以当成不存在。——W3C**\n\n**方案三：浮动+负的margin**\n\n这个方案还是挺有意思的。\n\n直接看代码吧，关键代码如下：\n\n```html\n <style>\n        #main,\n        .l,\n        .r {\n            float: left;\n        }\n        \n        #main {\n            width: 100%;\n        }\n        \n        .c {\n            margin-left: 100px;\n            margin-right: 200px;\n            background-color: blue;\n        }\n        \n        .l {\n            width: 100px;\n            background-color: grey;\n            margin-left: -100%;\n        }\n        \n        .r {\n            width: 200px;\n            background-color: grey;\n            margin-left: -200px;\n        }\n    </style>\n\n\n  \t<div id=\"main\">\n        <div class=\"c\">中间内容</div>\n    </div>\n    <div class=\"l\">左边内容</div>\n    <div class=\"r\">右边内容</div>\n```\n\n上面这段代码，关键在于，main宽度是100%，c只是在宽度100%的基础上设置了margin，以便容纳左右两栏。main必须在l和r之前，**原因在于l和r中的margin-left值得选取是在有main的基础上进行的，设置了margin-left的值之后就可以使左右两栏分别置于左右**\n\nl和r中的margin-left的值的选取：**首先需要去理解的是文档流之所以会“垂直”排列在浏览器中，是因为浏览器的宽度不够宽，当然这个说法不够严谨。严谨的观点：对于宽度是100%的元素，其后的元素只能放在下一行；对于内联元素，如果当某一元素在第n行时，第n行所有元素总的宽度大于浏览器宽度时，该元素只能放在下一行。把某一行元素移动到下一行对应位置，只需要把该元素的margin-left值设置为100%即可**\n\n**方案四：利用inline-block**\n\n从segmentfault上copy来的代码如下：\n\n**但是对这段代码人就有很大疑问？**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>test_float</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        \n        .content,\n        .right,\n        .left {\n            display: inline-block;\n            font-size: 16px;\n            letter-spacing: normal;\n        }\n        \n        .box {\n            font-size: 0;  <!--  目的是为了使inline-block元素之间消除4px的空白-->\n            letter-spacing: -4px;\n            padding-left: 100px;\n            padding-right: 200px;\n        }\n        \n        .content {\n            width: 100%;\n            background-color: blue;\n        }\n        \n        .left {\n            width: 100px;\n            margin-left: -100px;\n            position: relative;\n            background-color: grey;\n            left: -100%;\n        }\n        \n        .right {\n            position: relative;\n            width: 200px;\n            margin-left: -200px;\n            left: 200px;\n            background-color: grey;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"box\">\n        <div class=\"content\">中间内容</div>\n        <div class=\"left\">左边内容</div>\n        <div class=\"right\">右边内容</div>\n    </div>\n\n</body>\n\n</html>\n```\n\n\n\n**方案五：利用calc()和inline-block特点**（方案五和方案四有很大的相似之处）\n\n代码如下，当然其中box设置font-size为0还是不太明白是何用意\n\n```Html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>test_float</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        \n        .content,\n        .right,\n        .left {\n            display: inline-block;\n            font-size: 16px;\n            letter-spacing: normal;\n        }\n        \n        .box {\n            font-size: 0;\n            letter-spacing: -4px;\n        }\n        \n        .left {\n            width: 100px;\n            background-color: grey;\n        }\n        \n        .content {\n            width: calc(100% - 300px);\n            background-color: blue;\n        }\n        \n        .right {\n            width: 200px;\n            background-color: grey;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"box\">\n        <div class=\"left\">左边内容</div>\n        <div class=\"content\">中间内容</div>\n\n        <div class=\"right\">右边内容</div>\n    </div>\n\n</body>\n\n</html>\n```\n\n\n\n**方案六：利用flex**\n\nflex是一个新东西，也是我个人觉得挺重要的一个东西，所以会新开一篇博文。\n\nLoading...\n\n\n\n\n\n","tags":["阅读整理"],"categories":["CSS"]},{"title":"Nginx+thinkphp MAC Os","url":"/2017-02-20-Nginx-thinkphp-MAC-Os/","content":"\nNginx+PHP(FastCGI)的安装和配置\n\nThanks to [实战Nginx与PHP（FastCGI）的安装、配置与优化](http://ixdba.blog.51cto.com/2895551/806622)、[Nginx配置小记](http://arccode.net/2015/02/27/Nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E8%AE%B0/)\n\n### FastCGI\n\nFastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等，同时，FastCGI也被许多脚本语言所支持，其中就有PHP。\nFastCGI是从CGI发展改进而来的。传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后结果被返回给HTTP服务器。这在处理高并发访问时，几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少被使用了。\nFastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能\n\n### Nginx+FastCGI运行原理\n\nNginx不支持对外部程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket，（这个socket可以是文件socket，也可以是ip socket）。为了调用CGI程序，还需要一个FastCGI的wrapper（wrapper可以理解为用于启动另一个程序的程序），这个wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接纳到请求，然后派生出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据发送给客户端，这就是Nginx+FastCGI的整个运作过程\n\n![140224291](/Users/spades/Downloads/140224291.png)\n\n### **spawn-fcgi与PHP-FPM**\n\n前面介绍过，FastCGI接口方式在脚本解析服务器上启动一个或者多个守护进程对动态脚本进行解析，这些进程就是FastCGI进程管理器，或者称之为FastCGI引擎， spawn-fcgi与PHP-FPM就是支持PHP的两个FastCGI进程管理器。\n下面简单介绍spawn-fcgi与PHP-FPM的异同。\n\nspawn-fcgi是HTTP服务器lighttpd的一部分，目前已经独立成为一个项目，一般与lighttpd配合使用来支持PHP，但是ligttpd的spwan-fcgi在高并发访问的时候，会出现内存泄漏甚至自动重启FastCGI的问题。\n\nNginx是个轻量级的HTTP server，必须借助第三方的FastCGI处理器才可以对PHP进行解析，因此Nginx+spawn-fcgi的组合也可以实现对PHP的解析，这里不过多讲述。\n\nPHP-FPM也是一个第三方的FastCGI进程管理器，它是作为PHP的一个补丁来开发的，在安装的时候也需要和PHP源码一起编译，也就是说PHP-FPM被编译到PHP内核中，因此在处理性能方面更加优秀；同时它在处理高并发方面也比spawn-fcgi引擎好很多，因此，推荐Nginx+PHP/PHP-FPM这个组合对PHP进行解析。\n\nFastCGI 的主要优点是把动态语言和HTTP Server分离开来，所以Nginx与PHP/PHP-FPM经常被部署在不同的服务器上，以分担前端Nginx服务器的压力，使Nginx专一处理静态请求和转发动态请求，而PHP/PHP-FPM服务器专一解析PHP动态请求\n\n### 配置\n\n由于Nginx本身不会对PHP进行解析，因此要实现Nginx对PHP的支持，其实是将对PHP页面的请求交给fastCGI进程监听的IP地址及端口。如果把php-fpm当做动态应用服务器，那么Nginx其实就是一个反向代理服务器。Nginx通过反向代理功能实现对PHP的解析，这就是Nginx实现PHP动态解析的原理\n\n* 配置PHP\n\n  * Mac系统自带了PHP和php-fpm，不用安装\n\n  * 修改php-fpm的配置文件\n\n    找到php-fpm.conf文件(笔者环境下，文件所在位置是/private/etc/)，修改其中的error_log项，否则运行时会报错，log无法输出，需要为error_log添加打印路径\n\n* 启动php-fpm ：sudo php-fpm\n\n* 配置Nginx\n\n  * 把nginx.conf文件中将PHP传递给FastCGI部分的代码取消注释\n  * 修改fastcgi_param，fastcgi_param指令指定放置PHP动态程序的主目录\n\n  ```\n  #具体配置代码\n  location ~ \\.php$ {\n              root           /Users/spades/www;\n              fastcgi_pass   127.0.0.1:9000;\n              fastcgi_index  index.php;\n              fastcgi_param  SCRIPT_FILENAME  /Users/spades/www$fastcgi_script_name;\n              include        fastcgi_params;\n          }\n  ```\n\n  ​\t/Users/spades/www是笔者放置动态文件的目录\n\n  * 修改user，确保具有读取php文件的权限\n\n  ```\n  #user 用户 用户组\n  user spades staff;\n  ```\n\n  ​","tags":["阅读整理"],"categories":["运维"]},{"title":"Chrome+Ajax:$http方式无法读取本地文件mac下解决方法","url":"/2017-02-11-Chrome-Ajax-http方式无法读取本地文件mac下解决方法/","content":"\n### 环境\n\nOSX、Chrome\n\n### 解决方法\n\n- 配置chrome的启动参数\n\n  - 命令行实现：chrome可执行文件所在位置/可执行文件 + 配置启动参数\n\n    ```bash\n    $ /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --allow-file-access-from-files\n    ```\n\n    /Applications/Google\\ Chrome.app/Contents/MacOS是chrome所在路径\n\n    Google\\ Chrome是可执行文件\n\n    --allow-file-access-from-files是启动参数\n\n  - 编写shell脚本(实际上和命令行实现无区别)\n\n    ```shell\n    #!/bin/bash\n    cd \"/Applications/Google Chrome.app/Contents/MacOS\"\n    \"/Applications/Google Chrome.app/Contents/MacOS/Chrome.old\" --allow-file-access-from-files \"$@\"\n    ```\n\n    \"$@\"将参数独立分开，独立打印","tags":["个人总结"],"categories":["JavaScript"]},{"title":"css中的居中","url":"/2017-02-08-css中的居中/","content":"\n[原文：**Centering in CSS: A Complete Guide**](https://css-tricks.com/centering-css-complete-guide/?utm_source=ourjs.com)\n\n### 水平居中\n\n* 内联元素：通过text-align属性设置其基于父元素对齐\n\n* 块级元素：当设置了宽度时，可以将margin-left和margin-right设置为auto，使其水平对齐。但宽度设置为100%时，将看不到对齐效果\n\n* 不止一个块级元素：将块级元素的display属性设置为inline-block，利用内联的性质将其设为居中\n\n  各个块级框并排排列\n\n```html\n<main>\n  <div>this is a dog</div>\n  <div>this is a cat</div>\n  <div>this is a pig</div>\n</main>\n```\n\n```css\nmain{\n  text-align: center;\n}\nmain div{\n  display: inline-block;\n  text-align: left;\n  width: 100px;\n  background-color: #bebebe;\n  padding: 5px;\n  margin:20px auto;\n}\n```\n\n\n\n### 垂直居中\n\n* 内联元素\n\n  * 如果是单行：可以通过设置padding-top、padding-bottom为相同的值，实现垂直居中；因为某种原因padding没有办法用的时候，将line-height设置为height也可以实现居中效果\n  * 多行：可以设置padding-top和padding-bottom值相等；如果不行，将display设置为table-cell，vertical-align属性设置为middle实现垂直居中\n\n* 块级元素\n\n  * 如果知道元素高度：可以根据具体的值进行设置（不能适用多种设备，太过绝对化）\n  * 不知道元素高度：设置其高度为父元素高度的一半，再将其上移自身高度的一半（利用transform性质）\n\n  ```css\n  selector{\n    top: 50%;\n    transform: translateY(-50%);\n  }\n  ```\n\n\n\n### 同时设置水平、垂直居中\n\n* 如果知道具体的宽和高：通过设置具体的值使其实现居中效果\n* 不知道具体宽和高：通过transform性质进行设置","tags":["阅读整理"],"categories":["CSS"]},{"title":"about","url":"/about/index.html"}]